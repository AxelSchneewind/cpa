Directory structure:
└── cpa (working_broken)/
    ├── README.md
    ├── LICENSE
    ├── Makefile
    ├── cpp2py.py
    ├── dump_graphs.py
    ├── false_raise.py
    ├── requirements.txt
    ├── run_tests.sh
    ├── test_output.py
    ├── unsafe.py
    ├── pycpa/
    │   ├── __main__.py
    │   ├── cfa.py
    │   ├── configs.py
    │   ├── cpa.py
    │   ├── cpaalgorithm.py
    │   ├── params.py
    │   ├── preprocessor.py
    │   ├── specification.py
    │   ├── task.py
    │   ├── test.py
    │   ├── verdict.py
    │   ├── __pycache__/
    │   ├── analyses/
    │   │   ├── ARGCPA.py
    │   │   ├── CompositeCPA.py
    │   │   ├── FormulaBuilder.py
    │   │   ├── LocationCPA.py
    │   │   ├── PredAbsCEGAR.py
    │   │   ├── PredAbsCPA.py
    │   │   ├── PredAbsPrecision.py
    │   │   ├── PropertyCPA.py
    │   │   ├── StackCPA.py
    │   │   ├── ValueAnalysisCPA.py
    │   │   ├── __init__.py
    │   │   └── __pycache__/
    │   ├── ast/
    │   │   ├── ASTPreprocessor.py
    │   │   ├── EnsureReturn.py
    │   │   ├── ExpandAugAssign.py
    │   │   ├── RemoveBuiltins.py
    │   │   ├── SetExecutionContext.py
    │   │   ├── __init__.py
    │   │   ├── ast.py
    │   │   └── __pycache__/
    │   ├── config/
    │   │   ├── PredicateAnalysis.py
    │   │   ├── ReachabilityAnalysis.py
    │   │   ├── ValueAnalysis.py
    │   │   ├── ValueAnalysisMergeJoin.py
    │   │   └── __pycache__/
    │   ├── property/
    │   │   ├── ReachSafety.py
    │   │   └── __pycache__/
    │   ├── refinement/
    │   │   ├── cegar_helper.py
    │   │   └── __pycache__/
    │   └── utils/
    │       ├── visual.py
    │       └── __pycache__/
    └── test_progs/
        ├── cegar_example.py
        ├── collatz.py
        ├── collatz_safe.py
        ├── divide_path_bug.py
        ├── even_odd_accumulate_safe.py
        ├── even_odd_accumulate_unsafe.py
        ├── flag_loop_safe.py
        ├── nested_cegar_safe.py
        ├── nested_cegar_safe_explicit.py
        ├── nested_cegar_unsafe.py
        ├── nested_funcs_safe.py
        ├── off_by_one_bug.py
        ├── sum_cubes_safe.py
        ├── sum_cubes_unsafe.py
        ├── sum_mult_safe.py
        ├── sum_mult_unsafe.py
        ├── test1.py
        ├── test2.py
        ├── test3.py
        ├── test4.py
        ├── test5.py
        └── test6.py

================================================
File: README.md
================================================
# pycpa


## Contents

- transpilation from c to python:
    - a fixed [source file](cpp2py.py) for `cpp2py` is provided
    - a [script](benchmarks/prepare_c.sh) for preparing svbenchmark files for transpilation 
    - a [script](benchmarks/transpile_set.sh) for transpiling the programs of a given set of verification tasks to python programs
- an implementation of CPA in `pycpa` 
    - it currently supports Value-Analysis, BMC
    - it supports checking ReachSafety


## Generating Benchmarks
The `svcomp23` benchmark set is provided as a submodule in [`benchmarks/`](benchmarks/).
The benchmark sets can be extracted and transpiled to python programs using
```sh
make generate-benchmarks
```
Note that this can take up to 6h for the selected benchmark sets.

To generate an indiviual task set, use e.g.
```sh
make benchmarks/ReachSafety-Floats
```

## Running Benchmarks
The benchmark programs can be verified by running
```sh
make run-benchmarks
```



================================================
File: LICENSE
================================================
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.



================================================
File: Makefile
================================================


# venv is required for benchmark generation
venv:
	@echo 'setting up the virtual environment'
	python -m venv venv
	./venv/bin/pip install -r requirements.txt
	@echo 'use '
	@echo '  source venv/bin/activate'
	@echo 'to activate'

check-venv:
	@[ ! -z "$(VIRTUAL_ENV)" ] || (echo 'activate the virtual environment first using source venv/bin/activate' && exit 1)

# the cpp2py required for benchmark generation seems to be abandoned and has bugs
# use this target to use a (partially) fixed version supplied here
# Note: this still does not support e.g. goto
.phony: path-cpp2py
patch-cpp2py: cpp2py.py
	@echo 'patching cpp2py'
	@cp cpp2py.py ./venv/lib/python3.13/site-packages/cpp2py/cpp2py.py


# helper targets for benchmark generation
benchmarks/%.set:
	@echo 'converting c benchmarks to python'
	@make -C benchmarks $*.set 

benchmarks/%: benchmarks/%.set patch-cpp2py cpp2py.py
	@echo 'converting c benchmarks to python'
	@make -C benchmarks $*/ 

list-benchmarks:
	@echo benchmarks/*/ | sed  -e 's/ /\n/g' -e 's/benchmarks\///g' | sed -e '/^.*sv-/d'

regenerate-benchmark-%: benchmarks/%.set patch-cpp2py cpp2py.py
	@echo "converting c benchmark set $* to python"
	@rm -rf benchmarks/$*/
	@make -C benchmarks $*/ -B

# main target for generating benchmarks
generate-benchmarks: patch-cpp2py cpp2py.py 
	@echo "converting c benchmarks to python"
	@make -C benchmarks benchmarks -B

# main target for running benchmarks, TODO: define set of benchmark sets somewhere

run-benchmark-%: venv check-venv benchmarks/% cpp2py.py
	@echo 'running benchmark'
	python -m pycpa -p ReachSafety -c PredicateAnalysis --max-iterations 1 benchmarks/$*/*.py

run-benchmarks: run-benchmark-ReachSafety-Arrays/ run-benchmark-ControlFlow/ run-benchmark-Floats/ run-benchmark-Heap/ run-benchmark-Loops/ run-benchmark-ProductLines/ run-benchmark-Sequentialized/ run-benchmark-XCSP/ run-benchmark-Combinations/ 

run-benchmark-Test: 

run-examples: check-venv collatz.py unsafe.py
	python -m pycpa -p ReachSafety -c PredicateAnalysis --max-iterations 300 collatz.py unsafe.py benchmarks/Test/*.py

run-%: check-venv %.py
	python -m pycpa -p ReachSafety -c PredicateAnalysis --max-iterations 300 $*.py 



# separate file for testing
test: check-venv
	python -m pycpa.test



================================================
File: cpp2py.py
================================================
# taken from https://pypi.org/project/cpp2py/ with fixes applied

from pycparser import c_parser
from pycparser import c_ast
import pycparser
import io

import re

tab = '\t'
def write_one_line(buf, depth):
    return f'{tab:.{depth}}{buf}\n'


type_map = {
    'bool'     : 'bool',
    'int'      : 'int',
    'char'     : 'int',
    'float'    : 'float',
    'double'   : 'float'
}

class Ast2Py:
    def __init__(self):
        self.import_file_list=[]

    def import_list(self):
        ret = ''
        self.import_file_list = list(set(self.import_file_list))
        for i in self.import_file_list:
            ret += f'from {i} import *\n'
        return ret

    def ast2py(self, ast,start_line=0):
        ret = ''
        for i in ast.ext:
            ret += self.ast2py_one_node(i)
        return ret

    def ast2py_fast(self, ast, filelike):
        self.stack = list()
        depth = 0

        # uppermost level of ast
        for i in reversed(ast.ext):
            self.push_expr(i)
            self.push_newline(depth)

        while len(self.stack) > 0:
            element = self.stack.pop()
            match element:
                case str():
                    filelike.write(element)
                case int():
                    filelike.write('\n' + '\t'*element)
                    depth = element
                case _:
                    self.ast2py_fast_one_node(element, depth)
        return

    def push_newline(self, depth):
        assert isinstance(depth, int)
        self.stack.append(depth)

    def push_expr(self, expr):
        assert not isinstance(expr, int)
        self.stack.append(expr)

    def ast2py_fast_one_node(self, n, depth):
        match n:
            case c_ast.FuncDef():
                self.push_newline(depth)
                self.push_expr(n.body)
                self.push_newline(depth + 1)
                self.push_expr('):')

                # TODO: translate types to type hints
                if n.decl.type.args:
                    for i in reversed(n.decl.type.args.params[1:]):
                        assert isinstance(i, Decl)
                        if i.init:
                            self.push_expr(i.init)
                            self.push_expr('=')
                        if i.type and i.type.type:
                            self.push_expr(i.type.type)
                            self.push_expr(':')
                        self.push_expr(i.name)
                        self.push_expr(',')
                    self.push_expr(n.decl.type.args.params[0])

                self.push_expr('def %s (' % n.decl.name)

            case c_ast.Typedef():
                self.push_expr(n.type.type)
                self.push_expr(' = ')
                self.push_expr(n.type.declname)

            # TODO: initlist

            case c_ast.Compound():
                if n.block_items and len(n.block_items) > 0:
                    for i in reversed(n.block_items[1:]):
                        self.push_expr(i)
                        self.push_newline(depth)
                    self.push_expr(n.block_items[0])
                else:
                    self.push_newline(depth)
                    self.push_expr('pass')

            case c_ast.EmptyStatement():
                self.push_newline(depth)
                self.push_expr('pass')

            case c_ast.Return():
                self.push_newline(depth)
                if n.expr:
                    self.push_expr(n.expr)
                self.push_expr('return ')

            case c_ast.Constant():
                py_constant = str(n.value)
                if re.match(r'^0+x', py_constant): # hex
                    pass
                elif re.match(r'^0+[^.]', py_constant): # octal
                    py_constant = re.sub(r'^0+[^x]',  '0o', py_constant)

                py_constant = re.sub(r'[ULul]+$', '', py_constant)
                if len(py_constant) == 0 or py_constant == '0o':
                    py_constant = '0'
                self.push_expr(py_constant)

            case c_ast.ID():
                self.push_expr(n.name)

            case c_ast.Typename():
                selected = 'int'
                if n in type_map:
                    selected = str(type_map[n])
                self.push_expr(selected)

            case c_ast.Struct():
                if n.decls:
                    name = n.name

                    self.push_newline(depth)

                    # constructor
                    for d in reversed(n.decls):
                        self.push_newline(depth + 2)
                        self.push_expr(d)
                        self.push_expr('self.')
                    self.push_newline(depth + 2)

                    self.push_expr('):')
                    for d in reversed(n.decls):
                        self.push_expr(' = None')
                        self.push_expr(d)
                        self.push_expr(', ')

                    self.push_expr('def __self__(self')
                    self.push_newline(depth + 1)
                    self.push_expr(': ')
                    self.push_expr(name)
                    self.push_expr('class ')
                    self.push_newline(depth)

            case c_ast.TypeDecl():
                self.push_expr(n.type)

            case c_ast.IdentifierType():
                selected = 'int'
                for n in n.names:
                    if n in type_map:
                        selected = str(type_map[n])
                self.push_expr(selected)

            case c_ast.PtrDecl():
                self.push_expr('int')

            case c_ast.Decl():
                if n.init is not None:
                    self.push_expr(n.init)
                    self.push_expr(' = ')
                    self.push_expr(n.type.type)
                    self.push_expr(' : ')
                    self.push_expr(n.name)
                else:
                    #add char* support
                    if isinstance(n.type, c_ast.PtrDecl) and isinstance(n.type.type, c_ast.TypeDecl) and isinstance(n.type.type.type, c_ast.IdentifierType):
                        if n.type.type.type.names ==['char']:
                            ostr =  f'{n.declname} = CharPtr()'
                            self.import_file_list.append('cpp2py.cpp2py_ctype')
                            self.push_expr(ostr)
                    elif isinstance(n.type, c_ast.ArrayDecl) \
                        and isinstance(n.type.type, c_ast.TypeDecl) and \
                        isinstance(n.type.type.type, c_ast.IdentifierType):
                            identifier = n.type.type.declname
                            typ = n.type.type.type
                            dim = n.type.dim
                            self.push_expr(') ]')
                            self.push_expr(dim)
                            self.push_expr('() for i in range(')
                            self.push_expr(typ)
                            self.push_expr(' = [ ')
                            self.push_expr(identifier)
                            self.import_file_list.append('cpp2py.cpp2py_ctype')
                    elif isinstance(n.type, c_ast.Struct):
                        if n.type.decls:
                            name = n.type.name
                            for d in reversed(n.type.decls):
                                self.push_expr(d.name)
                                self.push_expr(' = ')
                                self.push_expr(d.name)
                                self.push_expr('self.')
                                self.push_newline(depth + 2)
        
                            self.push_expr('):')
                            for d in reversed(n.type.decls):
                                self.push_expr(' = None')
                                self.push_expr(d.type.type)
                                self.push_expr(' : ')
                                self.push_expr(d.name)
                                self.push_expr(', ')
        
                            self.push_expr('def __self__(self')
                            self.push_newline(depth + 1)
                            self.push_expr(': ')
                            self.push_expr(name)
                            self.push_expr('class ')
                            self.push_newline(depth)
                    elif isinstance(n.type.type, c_ast.Struct):
                        self.push_expr(n.type.type.name)
                        self.push_expr(': ')
                        self.push_expr(n.name)
                    else:
                        self.push_expr(n.type.type)
                        self.push_expr(': ')
                        self.push_expr(n.name)

            case c_ast.Assignment():
                self.push_expr(n.rvalue)
                self.push_expr(' ')
                self.push_expr(n.op)
                self.push_expr(' ')
                self.push_expr(n.lvalue)


            case c_ast.StructRef():
                self.push_expr(n.field)
                self.push_expr('.')
                self.push_expr(n.name)

            case c_ast.ArrayRef():
                self.push_expr(']')
                self.push_expr(n.subscript.value)
                self.push_expr('[')
                self.push_expr(n.name)

            case c_ast.Break():
                self.push_newline(depth)
                self.push_expr('break')

            case c_ast.Continue():
                self.push_newline(depth)
                self.push_expr('continue')

            case c_ast.DoWhile():
                self.push_newline(depth)

                self.push_expr('break')
                self.push_newline(depth + 2)
                self.push_expr(':')
                if n.cond:
                    self.push_expr(n.cond)
                else:
                    self.push_expr('False')
                self.push_expr('if not ')
                self.push_newline(depth + 1)

                self.push_expr(n.stmt)
                self.push_newline(depth + 1)
                self.push_expr('while True:')

            case c_ast.While():
                self.push_newline(depth)
                self.push_expr(n.stmt)
                self.push_newline(depth + 1)
                self.push_expr(':')
                if n.cond:
                    self.push_expr(n.cond)
                else:
                    self.push_expr('True')
                self.push_expr('while ')


            case c_ast.For():
                self.push_newline(depth)

                if n.next is not None:
                    self.push_expr(n.next)
                    self.push_newline(depth + 1)

                self.push_expr(n.stmt)
                self.push_newline(depth + 1)

                self.push_expr(':')
                if n.cond:
                    self.push_expr(n.cond)
                else:
                    self.push_expr('True')
                self.push_expr('while ')
                self.push_newline(depth)

                self.push_expr(n.init)
                
            case c_ast.If():
                if n.iffalse:
                    self.push_newline(depth)

                    self.push_expr(n.iffalse)
                    self.push_newline(depth + 1)

                    self.push_expr('else:')

                self.push_newline(depth)
                self.push_expr(n.iftrue)
                self.push_newline(depth + 1)

                self.push_expr(':')
                self.push_expr(n.cond)
                self.push_expr('if ')

            case c_ast.Switch():
                self.push_newline(depth)
                self.push_expr(n.stmt)
                self.push_newline(depth + 1)

                self.push_expr(':')
                self.push_expr(n.cond)
                self.push_expr('match ')

            case c_ast.Case():
                if all(not isinstance(s, c_ast.Break) for s in n.stmts):
                    print('Warning: case does not contain a break statement! (code nonequivalent)')

                for s in reversed(n.stmts):
                    self.push_expr(s)
                    self.push_newline(depth + 1)

                self.push_expr(':')
                self.push_expr(n.expr)
                self.push_expr('case ')

            case c_ast.Default():
                if all(not isinstance(s, c_ast.Break) for s in n.stmts):
                    print('Warning: case does not contain break statement!')

                for s in reversed(n.stmts):
                    self.push_expr(s)
                    self.push_newline(depth + 1)

                self.push_expr('case _:')


            # goto unsupported
            case c_ast.Goto():
                print('encountered goto, ignoring')
                self.push_expr('# goto ' + n.name)

            case c_ast.Label():
                self.push_expr(n.stmt)
                self.push_newline(depth)
                # label name becomes comment
                self.push_expr('# ' + n.name)


            case c_ast.BinaryOp():
                py_op = str(n.op)

                match py_op:
                    case '&&':
                        py_op = ' and '
                    case '||':
                        py_op = ' or '
                    case _:
                        py_op = py_op
                if isinstance(n.right, c_ast.BinaryOp):
                    self.push_expr(')')
                    self.push_expr(n.right)
                    self.push_expr('(')
                else:
                    self.push_expr(n.right)

                self.push_expr(py_op)

                if isinstance(n.left, c_ast.BinaryOp):
                    self.push_expr(')')
                    self.push_expr(n.left)
                    self.push_expr('(')
                else:
                    self.push_expr(n.left)

            case c_ast.UnaryOp():
                match n.op:
                    case '*':
                        self.push_expr('[0]')
                        self.push_expr(n.expr)
                    case '!':
                        self.push_expr(n.expr)
                        self.push_expr('not ')
                    case '++' | 'p++':
                        self.push_expr(' += 1 ')
                        self.push_expr(n.expr)
                    case '--' | 'p--':
                        self.push_expr(' -= 1 ')
                        self.push_expr(n.expr)
                    case  '-' | '+' | '~':
                        self.push_expr(n.expr)
                        self.push_expr(str(n.op))
                    # simulate dereference by id()
                    case  '&':
                        self.push_expr(')')
                        self.push_expr(n.expr)
                        self.push_expr('id(')
                    # simulate sizeof by .__get_sizeof__()
                    # maybe use sys.getsizeof() instead?
                    case 'sizeof':
                        self.push_expr('.__sizeof__()')
                        self.push_expr(n.expr)
                    case _:
                        print("Unknown UnaryOp", n.op)

            case c_ast.FuncCall():
                self.push_expr(')')

                if n.args:
                    self.push_expr(n.args.exprs[0])
                    for i in reversed(n.args.exprs[1:]):
                        self.push_expr(',')
                        self.push_expr(i)
                
                self.push_expr('(')
                self.push_expr(n.name.name)

            case c_ast.TernaryOp():
                self.push_expr(')')
                self.push_expr(n.iffalse)
                self.push_expr(') else (')
                self.push_expr(n.cond)
                self.push_expr(' if (')
                self.push_expr(n.iftrue)

            case c_ast.Cast():
                self.push_expr(')')
                self.push_expr(n.expr)
                self.push_expr('(')
                self.push_expr(n.to_type)

            case _:
                if n is not None:
                    print('Unknown ast type:', type(n))
                    print(str(n))
                    self.push_newline(depth)
                    self.push_expr('pass')



def c2py(input_c_file, output_py_file):
    # Create the parser and ask to parse the text. parse() will throw
    # a ParseError if there's an error in the code

    text = pycparser.preprocess_file(input_c_file)

    start_line=0
    parser = c_parser.CParser()
    ast = parser.parse(text, filename=input_c_file)

    f = open(output_py_file ,'w')

    # add transpiled code
    b=io.StringIO()
    a2py = Ast2Py()
    a2py.ast2py_fast(ast, b)
    py_cont = b.getvalue()

    # add required imports
    py_code = a2py.import_list()
    f.write(py_code)

    # py_cont = a2py.ast2py(ast, start_line)
    f.write(py_cont)

    # add entry point so that program can actually be run
    f.write('\n\n\n')
    f.write('if __name__ == "__main__":\n')
    f.write('\tmain()\n')




import sys

if __name__ == '__main__':
    if len(sys.argv) > 2:
        c2py(sys.argv[1],sys.argv[2])



================================================
File: dump_graphs.py
================================================
#!/usr/bin/env python3
"""
dump_graphs.py
==============

Create a folder `out/<prog-name>/` that contains
 • raw and pre-processed source
 • pretty AST print-out + rendered AST
 • rendered CFA
 • rendered ARG after the CEGAR run
 • small text summary (verdict, ARG size, #refinements, …)
"""

import ast, os, sys, textwrap, time
from pathlib import Path
from graphviz import Digraph

from pycpa.utils.visual import graphable_to_dot, ASTVisualizer, Graphable
from pycpa.preprocessor              import preprocess_ast
from pycpa.cfa                       import CFACreator
from pycpa.analyses.PredAbsCEGAR     import run_cegar, _analyse_once
from pycpa.analyses.PredAbsPrecision import PredAbsPrecision
from pycpa.task                      import Task      # CLI already builds one – we do too
from pycpa.specification             import ReachSafetySpecification


# --------------------------------------------------------------------------- #
# helper: write a small text file                                             #
# --------------------------------------------------------------------------- #
def _write(fname: Path, content: str | bytes) -> None:
    if isinstance(content, bytes):
        fname.write_bytes(content)
    else:
        fname.write_text(content, encoding="utf8")


# --------------------------------------------------------------------------- #
# main                                                                        #
# --------------------------------------------------------------------------- #
def main(source_file: str):
    src_path = Path(source_file).resolve()
    if not src_path.exists():
        sys.exit(f"error: {src_path} not found")

    out_dir  = Path("out") / src_path.stem
    out_dir.mkdir(parents=True, exist_ok=True)

    # 0) copy raw source -----------------------------------------------------
    raw_code = src_path.read_text(encoding="utf8")
    _write(out_dir / "program.py", raw_code)

    # 1) AST + pre-processed source -----------------------------------------
    raw_tree = ast.parse(raw_code, filename=str(src_path))
    tree     = preprocess_ast(raw_tree)             # same as CLI
    _write(out_dir / "program-preprocessed.py", ast.unparse(tree))

    import astpretty
    _write(out_dir / "astpretty", astpretty.pformat(tree, show_offsets=False))

    ASTVisualizer().visit(tree).graph.render(out_dir / "ast", cleanup=True)

    # 2) CFA -----------------------------------------------------------------
    cfa = CFACreator()
    cfa.visit(tree)
    graphable_to_dot(cfa.roots).render(out_dir / "cfa", cleanup=True)

    # 3) run CEGAR -----------------------------------------------------------
    entry         = cfa.entry
    specification = ['ReachSafety'] 
    task          = Task(max_iterations=100_000)    # generous default

    t0 = time.time()
    verdict = run_cegar(entry, cfa.roots, task, specification,
                        max_refinements=12, arg_node_cap=50_000,
                        verbose=False)
    runtime = time.time() - t0

    # 4) ARG visualisation ---------------------------------------------------
    # We need the ARG root.  The easiest way is to perform ONE MORE analysis
    # with the *final* precision that run_cegar ended with.  We reuse the
    # helper _analyse_once (it returns the CPAAlgorithm which holds the ARG).
    π_final  = PredAbsPrecision.from_cfa(cfa.roots).predicates   # crude but OK
    _, algo  = _analyse_once(entry, π_final, task, specification, arg_cap=1_000_000)

    arg_root = algo.cpa.arg_root     # provided by ARGCPA
    graphable_to_dot([arg_root]).render(out_dir / "arg", cleanup=True)

    # 5) small summary -------------------------------------------------------
    summary = textwrap.dedent(f"""
        Source file : {src_path}
        Verdict     : {verdict}
        ARG nodes   : {len(algo.cpa._arg_nodes)}
        Runtime     : {runtime:0.3f}s
    """).strip()
    _write(out_dir / "summary.txt", summary)
    print(summary)
    print(f"[OK]  results in {out_dir}/")


# --------------------------------------------------------------------------- #
if __name__ == "__main__":
    if len(sys.argv) != 2:
        sys.exit("usage: dump_graphs.py <python-source>")
    main(sys.argv[1])




================================================
File: false_raise.py
================================================
raise Exception("Unsafe path reached")



================================================
File: requirements.txt
================================================
astpretty
astunparse
cpp2py
graphviz  
pcpp
pip
pycparser
six
wheel



================================================
File: run_tests.sh
================================================
for prog in test_progs/*.py; do
  echo "=== Running $prog ==="
  python -m pycpa "$prog" -c PredicateAnalysis -p ReachSafety --max-iterations 1000
done




================================================
File: test_output.py
================================================



================================================
File: unsafe.py
================================================
def abort():
    pass
def reach_error():
    pass

def a():
    y = 2
    return y

def b():
    a()

def VERIFIER_assert(cond):
    if not cond:
        reach_error()
    else:
        pass
    return 

def main():
    x = 10
    y = 1
    z = 5
    while z > 1:
        y = x + y
        a()
        x += __ret
        if z % 2 == 0:
            z = z // 2
        else:
            z = 3 * z + 1
    VERIFIER_assert(False)
    b()
    c()



================================================
File: pycpa/__main__.py
================================================
#!/usr/bin/env python3
"""
Unified launcher for pycpa
==========================

* If PredicateAnalysis is among -c configs  →  CEGAR loop
* Otherwise run the classical CPAAlgorithm once
"""

from __future__ import annotations
import sys, ast, pathlib
from typing import List

from pycpa.params  import parser
from pycpa import configs
from pycpa.preprocessor import preprocess_ast
from pycpa.cfa            import CFACreator, CFANode
from pycpa.task           import Task, Result
from pycpa.verdict        import Verdict
from pycpa.analyses       import CompositeCPA, ARGCPA
from pycpa.cpaalgorithm   import CPAAlgorithm, Status

# CEGAR driver (uses PredicateAnalysis helpers)
from pycpa.analyses.PredAbsCEGAR import run_cegar

# --------------------------------------------------------------------------- #
#  helper: run classical CPA stack once                                       #
# --------------------------------------------------------------------------- #
def _run_once(entry: CFANode,
              cfa_roots: List[CFANode],
              args):
    analysis_mods      = [configs.load_cpa(c)           for c in args.config]
    specification_mods = [configs.load_specification(p) for p in args.property]

    cpas = []
    for m in analysis_mods:
        cpas.extend(m.get_cpas(entry_point=entry,
                               cfa_roots=cfa_roots,
                               output_dir=None))
    for s in specification_mods:
        cpas.extend(s.get_cpas(entry_point=entry,
                               cfa_roots=cfa_roots,
                               output_dir=None))

    cpa   = ARGCPA(CompositeCPA(cpas))
    init  = cpa.get_initial_state()
    wl    = {init};  reached = {init}
    result = Result()
    algo  = CPAAlgorithm(cpa,
                         Task(args.program[0], args.config, args.property,
                              max_iterations=args.max_iterations),
                         result,
                         specification_mods)
    algo.run(reached, wl, args.max_iterations)

    print("Status:", result.status)
    for i, spec in enumerate(specification_mods):
        v = spec.check_arg_state(init)
        print(f"{args.property[i]}: {v}")

# --------------------------------------------------------------------------- #
#  analyse a single input file                                                #
# --------------------------------------------------------------------------- #
def analyse_one(program: str, args):
    name = pathlib.Path(program).stem
    print(f"\n[VERIFICATION] Verifying {name} using {args.config} against {args.property}")

    # 1. preprocess & parse
    src   = pathlib.Path(program).read_text()
    tree  = preprocess_ast(ast.parse(src))

    # 2. build CFA
    creator = CFACreator(); creator.visit(tree)
    entry   = creator.entry_point

    # 3. PredicateAnalysis present?  →  run CEGAR
    if "PredicateAnalysis" in args.config:
        verdict = run_cegar(
            entry           = entry,
            cfa_roots       = creator.roots,
            task            = Task(program, args.config, args.property,
                                   max_iterations=args.max_iterations),
            specification   = [configs.load_specification(p) for p in args.property],
            max_refinements = 12,
            arg_node_cap    = args.max_iterations,
            verbose         = args.verbose,
        )
        print("[VERIFICATION] Final verdict:", verdict)
    else:
        _run_once(entry, creator.roots, args)

# --------------------------------------------------------------------------- #
#  main                                                                       #
# --------------------------------------------------------------------------- #
if __name__ == "__main__":
    args = parser.parse_args()          # flags defined only in params.py
    sys.modules["__main__"].args = args # for verbose checks in other modules

    for prog in args.program:
        analyse_one(prog, args)



================================================
File: pycpa/cfa.py
================================================
#!/usr/bin/env python

import ast
from graphviz import Digraph
from typing import List, Optional 

# ### 1.2 Converting the AST into a CFA
# 
# For verification, we usually want to get the CFA of the program as an input.
# Constructing the CFA from an AST can be elegantly done using a visitor.
# Our strategy is to consider all nodes that affect control flow and
# take those subtrees that do not directly affect the control flow (like assumptions and statements) as edges in our CFA.
# We will call something that is either an assumption or a statement an `Instruction`.
# We also add some static utility methods to create `Instruction`s of both `InstructionType`s
# and negate an assumption in case it is on the `else` branch:

# In[7]:

from typing import List

from enum import Enum, auto


# class InstructionType(Enum):
#     STATEMENT = 1,
#     ASSUMPTION = 2,
#     CALL = 3,
#     RETURN = 4,
#     NONDET = 5,
#     EXIT = 5,
#     ABORT = 6,
#     REACH_ERROR = 7,
#     EXTERNAL = 8,
#     NOP = 9

class InstructionType(Enum):
    STATEMENT     = auto()
    ASSUMPTION    = auto()
    CALL          = auto()
    RETURN        = auto()
    NONDET        = auto()
    EXIT          = auto()
    ABORT         = auto()
    REACH_ERROR   = auto()
    EXTERNAL      = auto()
    NOP           = auto()

builtin_identifiers = {
    'exit'                          : InstructionType.EXIT,
    'abort'                         : InstructionType.ABORT,
    'call'                          : InstructionType.CALL,
    'return'                        : InstructionType.RETURN,
    'nondet'                        : InstructionType.NONDET,
    "assume"                        : InstructionType.ASSUMPTION,
    "nondet_int"                    : InstructionType.NONDET,
    '__VERIFIER_nondet_char'        : InstructionType.NONDET,
    '__VERIFIER_nondet_short'       : InstructionType.NONDET,
    '__VERIFIER_nondet_int'         : InstructionType.NONDET,
    '__VERIFIER_nondet_uint'        : InstructionType.NONDET,
    '__VERIFIER_nondet_ulong'       : InstructionType.NONDET,
    '__VERIFIER_nondet_long'        : InstructionType.NONDET,
    'reach_error'                   : InstructionType.REACH_ERROR,
}

builtin_identifiers["reach_error"] = InstructionType.REACH_ERROR

class Instruction:
    """An instruction is either an assignment or an assumption"""

    def __init__(self, expression, kind=InstructionType.STATEMENT, **params):
        self.kind = kind
        self.expression = expression
        for p in params:
            if not hasattr(self, p):
                setattr(self, p, params[p])

        match self.kind:
            case InstructionType.CALL:
                assert hasattr(self,'location')
                assert hasattr(self,'declaration')
    
    # def __str__(self):
    #     identifier = str(self.kind).replace('InstructionType.', '')
    #     match self.kind:
    #         case InstructionType.EXIT:
    #             code = self.exit_code if 'exit_code' in self.parameters else '0'
    #             return '%s(%s)' % (identifier, code)
    #         case InstructionType.CALL:
    #             return 'jump %s' % (self.location)
    #         case _:
    #             return '%s' % self.identifier

    def __str__(self):
        """
        Human-readable version of the instruction that never crashes.
        Uses `ast.unparse` (built-in since Python 3.9) for nice code
        snippets; falls back to `ast.dump` if unparse is unavailable.
        """
        try:
            from ast import unparse as _unparse
            _show = lambda e: _unparse(e).strip()
        except ImportError:                       # < 3.9
            _show = lambda e: ast.dump(e)

        match self.kind:
            case InstructionType.ASSUMPTION:
                return f"assume({_show(self.expression)})"
            case InstructionType.STATEMENT:
                return _show(self.expression)
            case InstructionType.CALL:
                return f"call {getattr(self, 'location', '?')}"
            case InstructionType.EXIT:
                code = getattr(self, 'exit_code', 0)
                return f"exit({code})"
            case _:
                return self.kind.name.lower()



    @staticmethod
    def assumption(expression, negated=False):
        if negated:
            expression = ast.UnaryOp(op=ast.Not(), operand=expression,
                lineno=expression.lineno, col_offset=expression.col_offset
            )
        return Instruction(expression, kind=InstructionType.ASSUMPTION, negated=negated)

    @staticmethod
    def statement(expression):
        return Instruction(expression)

    @staticmethod
    def builtin(expression, **params):
        name = str(expression.func.id).strip()
        if name in builtin_identifiers: 
            return Instruction(expression, kind=builtin_identifiers[name])
        else:
            return Instruction(expression, kind=InstructionType.EXTERNAL, **params)

    @staticmethod
    def ret(expression : ast.Return):
        return Instruction(expression, kind=InstructionType.RETURN)

    @staticmethod
    def call(expression: ast.Call, declaration: ast.FunctionDef, entry_point, exit_point_or_args: Optional[object] = None, argnames: Optional[List[ast.arg]] = None):
        """
        Build a CALL instruction.

        Supports both old and new call sites:

            • Instruction.call(node, decl, entry, args)          # old
            • Instruction.call(node, decl, entry, exit, args)    # new
        """
        # ------------------------------------------------------------------
        # 1.  Disambiguate the positional 4th argument
        # ------------------------------------------------------------------
        from pycpa.cfa import CFANode        # local import to avoid cycles

        if isinstance(exit_point_or_args, CFANode):
            exit_point = exit_point_or_args          # new style
        else:
            # old style: the 4th positional arg was the arg list
            exit_point = None
            if argnames is None:
                argnames = exit_point_or_args

        argnames = argnames or []

        # ------------------------------------------------------------------
        # 2.  Sanity checks and name extraction
        # ------------------------------------------------------------------
        def _to_str(x):
            """Return identifier string for ast.arg, ast.Name or str."""
            if isinstance(x, ast.arg):   # function parameters
                return str(x.arg)
            if isinstance(x, ast.Name):  # plain identifier expr
                return str(x.id)
            return str(x)  
                      # fallback (e.g. already a str)
        # every element must be a supported node
        assert all(isinstance(p, (ast.arg, ast.Name, str))
                for p in declaration.args.args), declaration.args.args
        assert all(isinstance(p, (ast.arg, ast.Name, str))
                for p in argnames), argnames

        param_names = [_to_str(p) for p in declaration.args.args]
        arg_names   = [_to_str(p) for p in argnames]

        # ------------------------------------------------------------------
        # 3.  Create and return the Instruction
        # ------------------------------------------------------------------
        return Instruction(
            expression,
            kind        = InstructionType.CALL,
            location    = entry_point,      # entry node of callee
            exit_point  = exit_point,       # may be None
            declaration = declaration,
            param_names = param_names,
            arg_names   = arg_names
        )

    @staticmethod
    def nop(expression):
        return Instruction(expression, kind=InstructionType.NOP)





# The  CFA then consists of nodes and edges, for which we declare separate classes.
# A `CFANode` has a numeric node id and a list of leaving and entering edges.
# A `CFAEdge` contains an `Instruction` as well as references to its predecessor and successor `CFANode`s:

# In[8]:

import astunparse
import astpretty

class CFANode:
    index = 0

    def __init__(self):
        self.node_id = CFANode.index
        self.entering_edges = list()
        self.leaving_edges = list()
        CFANode.index += 1

    def __str__(self):
        return "(%s)" % str(self.node_id)

    @staticmethod
    def merge(a, b):
        for entering_edge in b.entering_edges:
            entering_edge.successor = a
            a.entering_edges.append(entering_edge)
        for leaving_edge in b.leaving_edges:
            leaving_edge.predecessor = a
            a.leaving_edges.append(leaving_edge)
        b.entering_edges = list()
        b.leaving_edges = list()
        if CFANode.index == b.node_id + 1:
            CFANode.index -= 1
        return a

class CFAEdge:
    def __init__(self, predecessor, successor, instruction):
        self.predecessor = predecessor
        self.successor = successor
        predecessor.leaving_edges.append(self)
        successor.entering_edges.append(self)
        self.instruction = instruction

    def __str__(self):
        return "%s -%s-> %s" % (
            str(self.predecessor),
            self.label(),
            str(self.successor),
        )

    def label(self):
        if self.instruction.kind == InstructionType.ASSUMPTION:
            return str(self.instruction.expression.lineno) + ': [' + astunparse.unparse(self.instruction.expression).strip() + ']'
        elif self.instruction.kind == InstructionType.STATEMENT:
            return str(self.instruction.expression.lineno) + ': ' + astunparse.unparse(self.instruction.expression).strip()
        else:
            return '< %s >' % self.instruction.kind

# #### Task 3: Creating a CFA from an AST using a visitor (10 points)
# 
# The basic idea is to keep a stack of CFANodes (`self.node_stack`)
# where the top-most element always points to the node where we append the subgraph generated for the current node (and its children).
# Upon entering a node, we generally pop that CFANode from the stack since this is where we append new nodes.
# Once we are done with a node we push its leaving edges back to the stack.
# 
# The following implementation has everything needed for simple programs.
# It just lacks implementation for `break` and `continue`, which will be your task to add.
# (The current implementation considers these statements as no-ops. Please fix it.)

# In[9]:


import ast

# TODO: somehow track scopes and make variable names fully qualified
# TODO: function for creating temporary variables


class CFACreator(ast.NodeVisitor):
    """
    Builds a control-flow automaton (CFA) from a Python AST.

    After visiting an entire module you can read:
        self.entry_point        – CFANode  (first node of main code)
        self.roots              – list[CFANode] (one root per function, plus 0th = global)
    """

    # ------------------------------------------------------------------ #
    # init                                                               #
    # ------------------------------------------------------------------ #
    def __init__(self) -> None:
        super().__init__()

        self.global_root = CFANode()          # first node of top-level code
        self.entry_point = self.global_root   # <-- attribute main() expects
        self.roots: list[CFANode] = [self.global_root]

        # work-stacks
        self.node_stack     : list[CFANode] = [self.global_root]
        self.break_stack    : list[CFANode] = []
        self.continue_stack : list[CFANode] = []

        # function maps
        self.function_def         : dict[str, ast.FunctionDef] = {}
        self.function_entry_point : dict[str, CFANode] = {}
        self.function_exit_point  : dict[str, CFANode] = {}

    # ------------------------------------------------------------------ #
    # generic visitors                                                   #
    # ------------------------------------------------------------------ #
    def visit_Module(self, node: ast.Module):
        for stmt in node.body:
            self.visit(stmt)

    # -------- function definitions ------------------------------------ #
    def visit_FunctionDef(self, node: ast.FunctionDef):
        entry = CFANode(); exit_ = CFANode()
        caller = self.node_stack[-1]          # current basic block
        CFAEdge(caller, entry, Instruction.nop(node))   # skip over def

        self.function_def[node.name]         = node
        self.function_entry_point[node.name] = entry
        self.function_exit_point [node.name] = exit_
        self.roots.append(entry)

        # visit body
        self.node_stack.append(entry)
        for stmt in node.body:
            self.visit(stmt)
        body_exit = self.node_stack.pop()

        CFAEdge(body_exit, exit_, Instruction.nop(node))
        self.node_stack.append(exit_)        # continue after def

    # ------------------------------------------------------------------ #
    # loops                                                              #
    # ------------------------------------------------------------------ #
    def visit_While(self, node: ast.While):
        head = self.node_stack.pop()

        body_entry = CFANode()
        CFAEdge(head, body_entry, Instruction.assumption(node.test))

        loop_exit = CFANode()
        CFAEdge(head, loop_exit,
                Instruction.assumption(node.test, negated=True))

        self.break_stack.append(loop_exit)
        self.continue_stack.append(head)

        self.node_stack.append(body_entry)
        for stmt in node.body:
            self.visit(stmt)
        body_exit = self.node_stack.pop()
        CFANode.merge(head, body_exit)

        self.continue_stack.pop(); self.break_stack.pop()
        self.node_stack.append(loop_exit)

    def visit_Break(self, node: ast.Break):
        pred = self.node_stack.pop()
        CFAEdge(pred, self.break_stack[-1], Instruction.nop(node))
        self.node_stack.append(CFANode())     # dead successor

    def visit_Continue(self, node: ast.Continue):
        pred = self.node_stack.pop()
        CFAEdge(pred, self.continue_stack[-1], Instruction.nop(node))
        self.node_stack.append(CFANode())

    # ------------------------------------------------------------------ #
    # conditionals                                                       #
    # ------------------------------------------------------------------ #
    def visit_If(self, node: ast.If):
        entry = self.node_stack.pop()

        t_entry = CFANode()
        CFAEdge(entry, t_entry, Instruction.assumption(node.test))
        self.node_stack.append(t_entry)
        for s in node.body:
            self.visit(s)
        t_exit = self.node_stack.pop()

        f_entry = CFANode()
        CFAEdge(entry, f_entry,
                Instruction.assumption(node.test, negated=True))
        self.node_stack.append(f_entry)
        for s in node.orelse:
            self.visit(s)
        f_exit = self.node_stack.pop()

        merged = CFANode.merge(t_exit, f_exit)
        self.node_stack.append(merged)

    # ------------------------------------------------------------------ #
    # CALL-handling helper                                               #
    # ------------------------------------------------------------------ #
    def _build_call_edges(self, call: ast.Call, ret_var: str | None):
        # reach_error special-case
        if isinstance(call.func, ast.Name) and call.func.id == "reach_error":
            pred = self.node_stack.pop()
            succ = CFANode()
            succ.is_error = True                 # <-- add this line
            CFAEdge(pred, succ, Instruction.builtin(call))
            self.node_stack.append(succ)
            return

        fname = call.func.id if isinstance(call.func, ast.Name) else None
        if fname not in self.function_entry_point:
            # unknown – external
            pred = self.node_stack.pop(); succ = CFANode()
            CFAEdge(pred, succ, Instruction.builtin(call))
            self.node_stack.append(succ)
            return

        # known function
        entry  = self.function_entry_point[fname]
        exit_  = self.function_exit_point [fname]
        decl   = self.function_def[fname]

        arg_names = [
            n.id if isinstance(n, ast.Name) else f"tmp_const_{i}"
            for i, n in enumerate(call.args)
        ]

        pre  = self.node_stack.pop()
        post = CFANode()

        instr = Instruction.call(call, decl, entry, exit_, arg_names)
        instr.ret_var = ret_var

        CFAEdge(pre,  entry, instr)          # CALL
        CFAEdge(exit_, post, Instruction.nop(call))  # RETURN
        self.node_stack.append(post)

    # ------------------------------------------------------------------ #
    # statements                                                         #
    # ------------------------------------------------------------------ #
    def visit_Assign(self, node: ast.Assign):
        if isinstance(node.value, ast.Call) and isinstance(node.targets[0], ast.Name):
            self._build_call_edges(node.value, ret_var=node.targets[0].id)
        else:
            if not self.node_stack:
                self.node_stack.append(CFANode())
            pred = self.node_stack.pop(); succ = CFANode()
            CFAEdge(pred, succ, Instruction.statement(node))
            self.node_stack.append(succ)

    def visit_Expr(self, node: ast.Expr):
        if isinstance(node.value, ast.Call):
            self._build_call_edges(node.value, ret_var=None)
        else:
            pred = self.node_stack.pop(); succ = CFANode()
            CFAEdge(pred, succ, Instruction.statement(node.value))
            self.node_stack.append(succ)

    def visit_Return(self, node: ast.Return):
        pred = self.node_stack.pop(); succ = CFANode()
        CFAEdge(pred, succ, Instruction.ret(node))
        self.node_stack.append(succ)

    def visit_Assert(self, node: ast.Assert):
        pred = self.node_stack.pop()
        succ = CFANode()
        CFAEdge(pred, succ, Instruction.assumption(node.test))
        # print(f"[DEBUG CFA] assert→assume edge for {ast.dump(node.test)}")
        self.node_stack.append(succ)

    def visit_Raise(self, node: ast.Raise):
        # Pop the current block, create an error‐successor, and mark it.
        pred = self.node_stack.pop()
        succ = CFANode()
        succ.is_error = True

        # Emit a genuine REACH_ERROR–kind edge, not just a statement.
        CFAEdge(pred, succ, Instruction(node, kind=InstructionType.REACH_ERROR))
        # print(f"[DEBUG CFA] raise→error-edge for {ast.dump(node)}")

        # Continue from the “error” node (so other passes see it).
        self.node_stack.append(succ)

# You can use the code below to draw the generated CFAs for manual inspection.
# Essentially, a `CFANode` is wrapped into `GraphableCFANode`, which implements the `Graphable` interface.
# The method `graphable_to_dot` then takes a `Graphable` state and plots everything that is reachable from that state.

# In[10]:

class Graphable:
    def get_node_label(self):
        pass

    def get_edge_labels(self, other):
        pass

    def get_successors(self):
        pass

class GraphableCFANode(Graphable):
    def __init__(self, node):
        assert isinstance(node, CFANode)
        self.node = node

    def get_node_label(self):
        return str(self.node.node_id)

    def get_edge_labels(self, other):
        return [
            edge.label()
            for edge in self.node.leaving_edges
            if edge.successor == other.node
        ]

    def get_successors(self):
        return [GraphableCFANode(edge.successor) for edge in self.node.leaving_edges]

    def __eq__(self, other):
        return self.node == other.node

    def __hash__(self):
        return self.node.__hash__()

def graphable_to_dot(roots, nodeattrs={"shape": "circle"}):
    assert isinstance(roots, list)
    dot = Digraph()
    for (key, value) in nodeattrs.items():
        dot.attr("node", [(key, value)])
    for root in roots:
        dot.node(root.get_node_label())
        waitlist = set()
        waitlist.add(root)
        reached = set()
        reached.add(root)
        while not len(waitlist) == 0:
            node = waitlist.pop()
            for successor in node.get_successors():
                for edgelabel in node.get_edge_labels(successor):
                    dot.edge(node.get_node_label(), successor.get_node_label(), edgelabel)
                if not successor in reached:
                    waitlist.add(successor)
                    reached.add(successor)
                    dot.node(successor.get_node_label())
    return dot




================================================
File: pycpa/configs.py
================================================
import importlib

def load_cpa(name : str):
    modname = 'pycpa.config.' + name
    return importlib.import_module(modname)

def load_specification(name : str):
    modname = 'pycpa.property.' + name
    return importlib.import_module(modname)



================================================
File: pycpa/cpa.py
================================================
#!/usr/bin/env python

from pycpa.cfa import CFAEdge

# ## 2. Introducing CPAs (7 tasks, 72 points)
# 
# Now that we managed to create CFAs from our programs, it is time to build the basis for verification.
# As we learned, a flexible way to describe data-flow analysis and model checking is
# using the concept of Configurable Program Analysis (CPA).
# The basic interface of CPA is given below:

# In[12]:


from typing import Collection


class AbstractState(object):
    pass

class WrappedAbstractState(AbstractState):
    @staticmethod
    def unwrap_fully(state) -> Collection[AbstractState]:
        result = []

        for s in WrappedAbstractState.unwrap(state):
            for sub in WrappedAbstractState.unwrap(s):
                result.append(sub)
        return result

    @staticmethod
    def unwrap(state) -> Collection[AbstractState]:
        if hasattr(state, 'wrapped_state'):
            return [ state.wrapped_state ]
        elif hasattr(state, 'wrapped_states'):
            return list(state.wrapped_states)
        elif hasattr(state, 'wrapped'):
            return state.wrapped()
        else:
            return [state]
 
    


class TransferRelation:
    def get_abstract_successors(self, predecessor: AbstractState) -> Collection[AbstractState]:
        raise NotImplementedError("get_abstract_successors not implemented!")

    def get_abstract_successors_for_edge(self, predecessor: AbstractState, edge: CFAEdge) -> Collection[AbstractState]:
        raise NotImplementedError("get_abstract_successors_for_edge not implemented!")


class StopOperator:
    def stop(self, state: AbstractState, reached: Collection[AbstractState]) -> bool:
        raise NotImplementedError("stop not implemented!")


class MergeOperator:
    def merge(self, state1: AbstractState, state2: AbstractState) -> AbstractState:
        raise NotImplementedError("merge not implemented!")


class CPA:
    def get_initial_state(self) -> AbstractState:
        raise NotImplementedError("get_initial_state not implemented!")

    def get_transfer_relation(self) -> TransferRelation:
        raise NotImplementedError("get_transfer_relation not implemented!")

    def get_merge_operator(self) -> MergeOperator:
        raise NotImplementedError("get_merge_operator not implemented!")

    def get_stop_operator(self) -> StopOperator:
        raise NotImplementedError("get_stop_operator not implemented!")



# #### Task 10: Implementing the merge-join operators (3 points)
# 
# Please implement a different merge operator that joins the `ValueState`s instead of the currently used `MergeSepOperator`.

# In[32]:


class MergeJoinOperator(MergeOperator):
    def merge(self, e: AbstractState, eprime: AbstractState) -> AbstractState:
        # TODO
        return eprime




# In `TransferRelation`, we have
# - $e \rightsquigarrow e'$ as `get_abstract_successors(self, predecessor)` and
# - $e \stackrel{g}{\rightsquigarrow} e'$ as `get_abstract_successors_for_edge(self, predecessor, edge)`,
#   where $g$ corresponds to the `CFAEdge` named `edge`.
# 
# #### Task 4: Merge-Sep and Stop-Sep Operators (6 points)
# 
# Please define the merge-sep and stop-sep operators according to what we have learned in the class:

# In[13]:


class MergeSepOperator(MergeOperator):
    def merge(self, e: AbstractState, eprime: AbstractState) -> AbstractState:
        return eprime


class StopSepOperator(StopOperator):
    def __init__(self, subsumes):
        self.subsumes = subsumes

    def stop(self, state: AbstractState, reached: Collection[AbstractState]) -> bool:
        return any((self.subsumes(state, reached_state) for reached_state in reached))






================================================
File: pycpa/cpaalgorithm.py
================================================
#!/usr/bin/env python3
# pycpa/cpaalgorithm.py
"""
Work-list exploration algorithm with early error detection.

Changes
-------
1.  Accept an optional *max_iterations* argument for backward
    compatibility with the old call-site that passed a third positional
    parameter.
2.  Detect *target* states on-the-fly.  A state is a target iff it (or
    any wrapped sub-state) implements ``is_target()`` and that method
    returns *True*.  Hitting a target terminates the search immediately
    with ``Status.ERROR`` so the surrounding CEGAR loop can report
    “FALSE”.
3.  Fixed a long-standing bug where the merge operator was invoked with
    the wrong argument order (it has to merge the *candidate successor*
    into a reached state).
"""

from pycpa.task import Status


class CPAAlgorithm:
    def __init__(self, cpa, task, result, specifications=None):
        self.cpa            = cpa
        self.task           = task
        self.result         = result
        self.specifications = specifications or []
        self.iterations     = 0

    # ------------------------------------------------------------ #
    # helpers                                                      #
    # ------------------------------------------------------------ #
    @staticmethod
    def _is_target(state):
        """Return True iff *state* (or any wrapped sub-state) is a target."""
        return hasattr(state, "is_target") and state.is_target()

    # ------------------------------------------------------------ #
    # main work-list loop                                          #
    # ------------------------------------------------------------ #
    def run(self, reached, waitlist, max_iterations=None):
        """
        Standard work-list exploration with *merge-sep* / *stop-sep*.

        Stops with:
            • Status.ERROR   – a target state has been reached
            • Status.TIMEOUT – iteration budget exhausted
            • Status.OK      – fix-point reached without errors
        """
        budget = max_iterations or self.task.max_iterations

        while waitlist:
            e = waitlist.pop()

            # 1) early error detection on the current state
            if self._is_target(e):
                self.result.status = Status.ERROR
                return

            # 2) budget check
            self.iterations += 1
            if budget and self.iterations >= budget:
                self.result.status = Status.TIMEOUT
                return

            # 3) explore successors
            for succ in self.cpa.get_transfer_relation().get_abstract_successors(e):

                # 3a) early error detection on the successor
                if self._is_target(succ):
                    self.result.status = Status.ERROR
                    return

                to_add, to_remove = set(), set()

                # 3b) merge-sep
                for reached_state in reached:
                    merged = self.cpa.get_merge_operator().merge(succ, reached_state)
                    if merged != reached_state:
                        to_remove.add(reached_state)
                        to_add.add(merged)

                # 3c) stop-sep
                if not self.cpa.get_stop_operator().stop(succ, reached):
                    to_add.add(succ)

                # 3d) maintain the two work sets
                reached -= to_remove
                waitlist -= to_remove
                reached |= to_add
                waitlist |= to_add

        # 4) fix-point reached, no error seen
        self.result.status = Status.OK



================================================
File: pycpa/params.py
================================================
#!/usr/bin/env python3
"""
Command-line interface shared by all pycpa entry points.
"""

import argparse

# --------------------------------------------------------------------------- #
#  Core parser                                                                #
# --------------------------------------------------------------------------- #
parser = argparse.ArgumentParser(
    prog        = "pycpa",
    description = "Predicate Abstraction, Value Analysis, and other CPAs "
                  "for Python/C benchmarks",
)

# --------------------------------------------------------------------------- #
#  Positional: program(s)                                                     #
# --------------------------------------------------------------------------- #
parser.add_argument(
    "program",
    nargs="+",
    help="one or more .py files to verify",
)

# --------------------------------------------------------------------------- #
#  Mandatory analysis / property choices                                      #
# --------------------------------------------------------------------------- #
parser.add_argument(
    "-c", "--config",
    action   = "append",
    required = True,
    metavar  = "CPA",
    help     = "analysis configuration to use "
               "(repeat for multiple CPAs; see --list-configs)",
)
parser.add_argument(
    "-p", "--property",
    action   = "append",
    required = True,
    metavar  = "SPEC",
    help     = "property to check "
               "(repeat for multiple specs; see --list-properties)",
)

# --------------------------------------------------------------------------- #
#  Optional listings                                                          #
# --------------------------------------------------------------------------- #
parser.add_argument(
    "--list-configs",
    action = "store_true",
    help   = "print available analysis configurations and exit",
)
parser.add_argument(
    "--list-properties",
    action = "store_true",
    help   = "print available specification modules and exit",
)

# --------------------------------------------------------------------------- #
#  Runtime knobs                                                              #
# --------------------------------------------------------------------------- #
parser.add_argument(
    "--max-iterations",
    type    = int,
    default = 50_000,
    metavar = "N",
    help    = "ARG node budget per run / CEGAR round (default: 50 000)",
)
parser.add_argument(
    "--verbose",
    action = "store_true",
    help   = "print each new predicate set and CEGAR round progress",
)



================================================
File: pycpa/preprocessor.py
================================================
# from pycpa.ast import ExpandAugAssign, ASTPreprocessor, EnsureReturn, RemoveBuiltins, ASTVisualizer, SetExecutionContext
# from pycpa.cfa import builtin_identifiers

# import ast

# transformers = [
#     ExpandAugAssign(),
#     RemoveBuiltins(set(builtin_identifiers.keys())),
#     SetExecutionContext(),
#     EnsureReturn(),
#     ASTPreprocessor(),
# ]

# def preprocess_ast(tree : ast.AST) -> ast.AST:
#     for t in transformers:
#         tree = t.visit(tree)
#     return tree

from pycpa.ast import (
    ExpandAugAssign, ASTPreprocessor, EnsureReturn,
    RemoveBuiltins, ASTVisualizer, SetExecutionContext
)
from pycpa.cfa import builtin_identifiers

import ast

transformers = [
    ExpandAugAssign(),
    RemoveBuiltins(set(builtin_identifiers.keys())),
    SetExecutionContext(),
    EnsureReturn(),
    ASTPreprocessor(),
]

def preprocess_ast(tree: ast.AST) -> ast.AST:
    # run the normal passes
    for t in transformers:
        tree = t.visit(tree)

    # --------------------------------------------------------------
    # *FIX*: ensure every ast.Call has .keywords (list) attribute
    # --------------------------------------------------------------
    for node in ast.walk(tree):
        if isinstance(node, ast.Call) and not hasattr(node, "keywords"):
            node.keywords = []           # repair in place

    return tree



================================================
File: pycpa/specification.py
================================================
from pycpa.analyses import ARGCPA, ARGState
from pycpa.cpa import WrappedAbstractState, CPA
from pycpa.verdict import Verdict

from typing import Collection

class ARGVisitor:
    def _walk_arg(self, root : ARGState):
        # yield root
        # for c in root.children:
        #     for d in self._walk_arg(c):
        #         yield d
        """
        Breadth-first iteration over the ARG without recursion.
        Prevents RecursionError on very large graphs.
        """
        from collections import deque
        todo   = deque([root])
        seen   = set()
        while todo:
            n = todo.popleft()
            if n in seen:
                continue
            seen.add(n)
            yield n
            # `children` is whatever field your ARG node uses
            for c in getattr(n, "children", []):
                todo.append(c)
                
    def visit(self, root : ARGState):
        for n in self._walk_arg(root):
            self.visit_cpas(n)
        return self

    def visit_cpas(self, state):
        t = type(state).__name__
        func = 'visit_' + str(t)

        if hasattr(self, func):
            getattr(self, func)(state)
        else:
            underlying = WrappedAbstractState.unwrap(state)
            for c in WrappedAbstractState.unwrap(state):
                if c is not state:
                    self.visit_cpas(c)

    def get_verdict(self) -> Verdict:
        raise NotImplementedError()


class Specification:
    def get_cpas(self) -> Collection[CPA]:
        raise NotImplementedError()

    def get_state_visitor(self) -> ARGVisitor:
        raise NotImplementedError()




================================================
File: pycpa/task.py
================================================


from typing import Collection

class Task:
    def __init__(self, program : str, configs : Collection[str] = [], properties : Collection[str] = [], max_iterations=None):
        self.program = program
        self.configs = configs
        self.properties = properties
        self.max_iterations = max_iterations
    
    def __str__(self):
        return '%s' % self.program

from enum import Enum

class Status(Enum):
    OK = 0,
    TIMEOUT = 1,
    OUT_OF_MEMORY = 2,
    ABORTED_BY_USER = 3,
    ERROR = 4

    def __str__(self):
        return Enum.__str__(self).replace('Verdict.', '')


from pycpa.verdict import Verdict

class Result:
    def __init__(self, verdict=Verdict.UNKNOWN, witness=None):
        self.arg_complete = False
        self.verdict = verdict
        self.witness = witness


================================================
File: pycpa/test.py
================================================
#!/usr/bin/env python

from pycpa.analyses import PredAbsPrecision
from pycpa.cfa import CFACreator, InstructionType
from pycpa.preprocessor import preprocess_ast

from pycpa.analyses import PredAbsCPA, PredAbsState, PredAbsTransferRelation, PredAbsPrecision


import ast
import astpretty
import astunparse

import graphviz
from graphviz import Digraph

import os
import sys





def test_precision(program : str):
    tree = ast.parse(program)
    cfa_creator = CFACreator()
    cfa_creator.visit(tree)
    entry_point = cfa_creator.entry_point

    # test formula generation using FormulaBuilder
    precision = PredAbsPrecision.from_cfa([entry_point])
    return precision


def test_formula(line : str, ssa_indices : dict[str,int]):
    # get a single cfa edge from the given line
    tree = ast.parse(line)
    cfa_creator = CFACreator()
    cfa_creator.visit(tree)
    entry_point = cfa_creator.entry_point
    assert len(entry_point.leaving_edges) > 0, tree.body
    edge = entry_point.leaving_edges[0]

    # test formula generation using FormulaBuilder
    match edge.instruction.kind:
        case InstructionType.STATEMENT:
            assert isinstance(edge.instruction.expression, ast.Assign)
            formula = PredAbsPrecision.ssa_from_assign(edge, ssa_indices=ssa_indices)
        case InstructionType.ASSUME:
            formula = PredAbsPrecision.ssa_from_assume(edge, ssa_indices=ssa_indices)
        case _:
            pass
    return formula


def test_transfer_relation(line : str, predecessor : PredAbsState, transfer_relation : PredAbsTransferRelation):
    # get a single cfa edge from the given line
    tree = ast.parse(line)
    cfa_creator = CFACreator()
    cfa_creator.visit(tree)
    entry_point = cfa_creator.entry_point
    assert len(entry_point.leaving_edges) > 0, tree.body
    edge = entry_point.leaving_edges[0]

    # test formula generation using FormulaBuilder
    successors = transfer_relation.get_abstract_successors_for_edge(predecessor, edge)
    print(successors[0])
    return successors[0]



test_program = '''a = 1
b = 2
c = a + b
c = (a == b) or (b == 3) or not (a == 1)
x = 10
y = x + y
z = collatz(z)
b = VERIFIER_assert((x%2 == 0)) '''


if __name__ == '__main__':
    # compute precision from cfa
    print('computing initial precision: ')
    precision = test_precision(test_program)
    print(precision)

    # compute ssa path formula
    print('computing clauses of formula for example program: ')
    ssa_indices = {}
    for line in test_program.split('\n'):
        print(line)
        formula = test_formula(line, ssa_indices)
        print(formula)

    # run cpa
    print('computing CPA state transfers: ')
    cpa = PredAbsCPA(precision)
    state = cpa.get_initial_state()
    transfer = cpa.get_transfer_relation()
    for line in test_program.split('\n'):
        print(line)
        state = test_transfer_relation(line, state, transfer)
        print(formula)








================================================
File: pycpa/verdict.py
================================================

from enum import Enum
class Verdict(Enum):
    TRUE = 0,
    FALSE = 1,
    UNKNOWN = 2

    def __and__(self, other):
        if self == Verdict.TRUE:
            return other
        elif self == Verdict.FALSE:
            return self
        elif self == Verdict.UNKNOWN and other == Verdict.TRUE:
            return self
        elif self == Verdict.UNKNOWN and (other == Verdict.FALSE or other == Verdict.UNKNOWN):
            return other
    
    def __str__(self):
        return Enum.__str__(self).replace('Verdict.', '')







================================================
File: pycpa/analyses/ARGCPA.py
================================================
#!/usr/bin/env python

# For keeping track of the predecessor-successor relationship among abstract states,
# we can wrap our CPAs into a CPA dedicated for constructing the *abstract reachability graph*, the `ARGCPA`:

# In[15]:

from pycpa.cpa import CPA, AbstractState, WrappedAbstractState, TransferRelation, MergeOperator, StopOperator
from pycpa.cfa import Graphable
from pycpa.analyses import LocationCPA

import ast
import astpretty
from graphviz import Digraph

import copy


class ARGState(AbstractState):
    index = 0

    def __init__(self, wrapped_state, parent=None):
        self.wrapped_state = wrapped_state
        self.state_id = ARGState.index
        ARGState.index += 1
        self.parents = set()
        if parent:
            self.parents.add(parent)
            parent.children.add(self)
        self.children = set()

    def __str__(self):
        return f"N{self.state_id} - {self.wrapped_state}"

    def is_target(self):
        return hasattr(self.wrapped_state, "is_target") and self.wrapped_state.is_target()


class ARGTransferRelation(TransferRelation):
    def __init__(self, wrapped_transfer_relation, arg_cpa):
        self.wrapped_transfer_relation = wrapped_transfer_relation
        self.arg_cpa = arg_cpa          # keep back-link

    def get_abstract_successors(self, predecessor):
        result = []
        for wrapped_succ in \
                self.wrapped_transfer_relation.get_abstract_successors(
                    predecessor.wrapped_state):
            succ = ARGState(wrapped_succ, predecessor)
            self.arg_cpa._arg_nodes.add(succ)      # ← NEW
            result.append(succ)
        return result



class ARGStopOperator(StopOperator):
    def __init__(self, wrapped_stop_operator):
        self.wrapped_stop_operator = wrapped_stop_operator

    def stop(self, e, reached):
        return self.wrapped_stop_operator.stop(
            e.wrapped_state, [eprime.wrapped_state for eprime in reached]
        )



class ARGMergeOperator(MergeOperator):
    def __init__(self, wrapped_merge_operator):
        self.wrapped_merge_operator = wrapped_merge_operator

    def merge(self, state1, state2):
        wrapped_state1 = state1.wrapped_state
        wrapped_state2 = state2.wrapped_state
        merge_result = self.wrapped_merge_operator.merge(wrapped_state1, wrapped_state2)
        if (
            merge_result == wrapped_state2
        ):  # and (wrapped_state1 != wrapped_state2 or all(parent1 in state2.parents for parent1 in state1.parents)):
            return state2
        else:
            # merge both into a new state:
            parents = state1.parents.union(state2.parents)
            children = state1.children.union(state2.children)
            new_state = ARGState(merge_result)
            for state in (state1, state2):
                for parent in state.parents:
                    parent.children.discard(state)
                    parent.children.add(new_state)
                state.parents = set()
                for child in state.children:
                    child.parents.discard(state)
                    child.parents.add(new_state)
                state.children = set()
            new_state.children = children
            new_state.parents = parents
            return new_state


class ARGCPA(CPA):
    def __init__(self, wrapped_cpa):
        self.wrapped_cpa = wrapped_cpa
        self.arg_root   = None          # will be set in get_initial_state()
        self._arg_nodes = set()         # grows in transfer relation

    def get_initial_state(self):
        root = ARGState(self.wrapped_cpa.get_initial_state())
        self.arg_root = root            # store the unique root
        self._arg_nodes = {root}
        return root

    def get_stop_operator(self):
        return ARGStopOperator(self.wrapped_cpa.get_stop_operator())

    def get_merge_operator(self):
        return ARGMergeOperator(self.wrapped_cpa.get_merge_operator())

    def get_transfer_relation(self):
        return ARGTransferRelation(self.wrapped_cpa.get_transfer_relation())



# For visualization of the resulting ARG, we can reuse the `Graphable` interface we used before:

# In[16]:


class GraphableARGState(Graphable):
    def __init__(self, arg_state):
        assert isinstance(arg_state, ARGState)
        self.arg_state = arg_state

    def get_node_label(self):
        return str("N%d\n%s" % (self.arg_state.state_id, self.arg_state.wrapped_state))

    def get_edge_labels(self, other):
        loc1 = self._extract_location(self)
        loc2 = self._extract_location(other)
        if loc1 and loc2:
            for leaving_edge in loc1.leaving_edges:
                if leaving_edge.successor == loc2:
                    return [leaving_edge.label()]
        if loc1:
            return [loc1.leaving_edges[0].label()]
        return ['']

    def _extract_location(self, state):
        waitlist = set()
        waitlist.add(state.arg_state)
        location = None
        while waitlist:
            current = waitlist.pop()
            waitlist.update(WrappedAbstractState.unwrap_fully(current))
            if isinstance(current, LocationCPA.LocationState):
                location = current.location
                break
        return location

    def get_successors(self):
        return [GraphableARGState(child) for child in self.arg_state.children]

    def __eq__(self, other):
        return self.arg_state == other.arg_state

    def __hash__(self):
        return self.arg_state.__hash__()





================================================
File: pycpa/analyses/CompositeCPA.py
================================================
#!/usr/bin/env python

# ### CompositeCPA: Achieving synergy with several CPAs
# 
# Several CPAs can be used in parallel to achieve synergy.
# For this purpose, we need `CompositeCPA`, which is given in the next cell.
# `CompositeCPA` delegates the merge and stop operations to the corresponding merge and stop operators of each component CPA.
# The implementation is given, and you can proceed to the next task.

# In[19]:

from pycpa.cpa import AbstractState, WrappedAbstractState, TransferRelation, MergeOperator, CPA
from pycpa.analyses import LocationCPA
from pycpa.analyses import LocationState

import itertools

class CompositeState(WrappedAbstractState):
    def __init__(self, wrapped_states):
        assert isinstance(wrapped_states, list) or isinstance(wrapped_states, set) or isinstance(wrapped_states, tuple), type(wrapped_states)
        assert len(wrapped_states) > 0
        self.wrapped_states = wrapped_states

    def is_target(self):
        return any(
            [
                hasattr(state, "is_target") and state.is_target()
                for state in self.wrapped_states
            ]
        )

    def __eq__(self, other):
        assert type(self) == type(other)
        if other is self:
            return True
        if len(self.wrapped_states) != len(other.wrapped_states):
            return False
        return all(a == b for (a, b) in zip(self.wrapped_states, other.wrapped_states))

    def __hash__(self):
        return tuple(
            wrapped_state.__hash__ for wrapped_state in self.wrapped_states
        ).__hash__()

    def __str__(self):
        if any((isinstance(w, WrappedAbstractState) for w in self.wrapped_states)):
            return " %s " % "\n".join([str(state) for state in self.wrapped_states])
        else:
            return "(%s)" % ", ".join([str(state) for state in self.wrapped_states])
    

class CompositeStopOperator(AbstractState):
    def __init__(self, wrapped_stop_operators):
        self.wrapped_stop_operators = wrapped_stop_operators

    def stop(self, e, reached):
        return any( # Exists any reached state that covers e?
                   all(# All components of e are covered by the corresponding component of eprime?
                       stop_op.stop(e_inner, [eprime_inner])
                       for stop_op, e_inner, eprime_inner in zip(self.wrapped_stop_operators, e.wrapped_states, eprime.wrapped_states)
                   )
                   for eprime in reached
               )


class CompositeTransferRelation(TransferRelation):
    def __init__(self, wrapped_transfer_relations):
        self.wrapped_transfer_relations = wrapped_transfer_relations

    def get_abstract_successors(self, predecessor):
        location_states = [
            state
            for state in WrappedAbstractState.unwrap_fully(predecessor)
            if isinstance(state, LocationState)
        ]
        if len(location_states) == 0:
            return [
                CompositeState(product)
                for product in itertools.product(
                    *[
                        transfer.get_abstract_successors(state)
                        for (transfer, state) in zip(
                            self.wrapped_transfer_relations, predecessor.wrapped_states
                        )
                    ]
                )
            ]
        else:
            location_state = location_states[0]
            result = list()
            for edge in location_state.location.leaving_edges:
                result += self.get_abstract_successors_for_edge(predecessor, edge)
            return result

    def get_abstract_successors_for_edge(self, predecessor, edge):
        return [
            CompositeState(product)
            for product in itertools.product(
                *[
                    transfer.get_abstract_successors_for_edge(state, edge)
                    for (transfer, state) in zip(
                        self.wrapped_transfer_relations, predecessor.wrapped_states
                    )
                ]
            )
        ]


class CompositeMergeOperator(MergeOperator):
    """
    Merge-Agree: All wrapped states are merged pairwise.
    Example:

        merge((l, e), (l', e')) = (merge_L(l, l'), merge_E(e, e'))

    If any of the resulting merges does not cover both its input states
    (i.e., e \\leq merge_E(e, e') and e' \\leq merge_E(e, e'))
    then the second input (e.g., (l', e')) is returned.
    """

    def __init__(self, wrapped_merge_operators, wrapped_stop_operators):
        self.wrapped_merge_operators = wrapped_merge_operators
        self.wrapped_stop_operators = wrapped_stop_operators

    def merge(self, state1, state2):
        merge_results = list()
        wrapped_states1 = state1.wrapped_states
        wrapped_states2 = state2.wrapped_states
        for s1, s2, merge_operator, stop_operator in zip(
            wrapped_states1, wrapped_states2, self.wrapped_merge_operators, self.wrapped_stop_operators
        ):
            merge_result = merge_operator.merge(s1, s2)
            # Use the stop operator to check whether the merge result covers s1.
            # If it does not, we prevent merging for all wrapped states and return
            # state2.
            if not stop_operator.stop(s1, [merge_result]):
                return state2
            merge_results.append(merge_result)
        if all(sold == snew for sold, snew in zip(wrapped_states2, merge_results)):
            # If all merges were merge^sep, there's no need to create a new object
            # and we return state2.
            return state2
        return CompositeState(merge_results)


class CompositeCPA(CPA):
    def __init__(self, wrapped_cpas):
        self.wrapped_cpas = wrapped_cpas

    def get_initial_state(self):
        return CompositeState(
            [wrapped_cpa.get_initial_state() for wrapped_cpa in self.wrapped_cpas]
        )

    def get_stop_operator(self):
        return CompositeStopOperator(
            [wrapped_cpa.get_stop_operator() for wrapped_cpa in self.wrapped_cpas]
        )

    def get_merge_operator(self):
        return CompositeMergeOperator(
            [cpa.get_merge_operator() for cpa in self.wrapped_cpas],
            [cpa.get_stop_operator() for cpa in self.wrapped_cpas]
        )

    def get_transfer_relation(self):
        return CompositeTransferRelation(
            [wrapped_cpa.get_transfer_relation() for wrapped_cpa in self.wrapped_cpas]
        )






================================================
File: pycpa/analyses/FormulaBuilder.py
================================================
from pysmt.shortcuts import *
import pysmt.typing as types
import pysmt

from pycpa.cfa import Instruction, InstructionType, CFANode

import ast
import astpretty
import astunparse

import re

from typing import Collection



# TODO: support more types 
class FormulaBuilder(ast.NodeVisitor):
    """ NodeVisitor that computes a formula from expressions on CFA-edges """

    # types used in formulas
    int_type = types.BV64
    bool_type = types.BOOL


    # use bitvectors for all variables
    # creates a constant from the given value
    @staticmethod
    def BV(val):
        match val:
            case bool():
                result = get_env().formula_manager.BV(0, 64)
                if val:
                    return BVNot(result)
                return result
            case int():
                return get_env().formula_manager.BV(val, 64)
            case _:
                return get_env().formula_manager.BV(0, 64)

    # not used currently
    @staticmethod
    def Bool(val):
        match val:
            case bool():
                return get_env().formula_manager.Bool(val)
            case int():
                return get_env().formula_manager.Bool(val != 0)
            case _:
                return get_env().formula_manager.Bool(0)

    @staticmethod
    def BV_to_Bool(bv):
        return NotEquals(bv, FormulaBuilder.BV(0))

    @staticmethod
    def Bool_to_BV(b):
        assert get_type(b) == types.BOOL
        return Ite(b, FormulaBuilder.BV(1), FormulaBuilder.BV(0))


    def __init__(self, instruction : Instruction, current_type=dict(), ssa_indices=None, required_type=int_type):
        """
            takes a single instruction and computes a formula from it
        """

        self.instruction = instruction
        self.current_type = current_type

        self.enable_ssa = (ssa_indices is not None)
        self.ssa_indices = ssa_indices

        self.required_type = required_type

    
    def store_type(self, name, current):
        assert isinstance(name, str)
        self.current_type[name] = current

    def lookup_type(self, name):
        assert isinstance(name, str)
        return self.int_type

    def ssa_current_identifier(self, name):
        assert isinstance(name, str)
        pattern = r'[0-9]+$'
        assert re.match(name, pattern) is None

        if self.enable_ssa:
            if not name in self.ssa_indices:
                self.ssa_indices[name] = 0
            return name + str(self.ssa_indices[name])
        else:
            return name
    
    def ssa_advance_identifier(self, name):
        assert isinstance(name, str)
        pattern = r'[0-9]+$'
        assert re.match(name, pattern) is None

        if self.enable_ssa:
            if not name in self.ssa_indices:
                self.ssa_indices[name] = 0
            self.ssa_indices[name] += 1
            return name + str(self.ssa_indices[name])
        else:
            return name

    def make_variable(self, name, required_type):
        if required_type is None:
            required_type = self.int_type
        return Symbol(name, required_type)

    def cast(self, value, required_type):
        actual_type = get_type(value)
        if required_type == actual_type:
            return value

        match required_type, actual_type:
            case self.int_type, self.bool_type:
                value = self.Bool_to_BV(value)
            case self.bool_type, self.int_type:
                value = self.BV_to_Bool(value)

        assert get_type(value) == required_type
        return value

    def make_equality(self, left, right):
        if get_type(right) != get_type(left):
            right = self.cast(right, get_type(left))
        match get_type(left):
            case self.bool_type:
                result = Iff(left, right)
            case self.int_type:
                result = Equals(left, right)
            case _:
                assert False
        return result

    def visit(self, node, required_type=None, is_rvalue=True):
        """ generic visit function, overwritten to pass required_type and is_rvalue """

        t = str(type(node).__name__)
        attrname = 'visit_' + t

        # 
        result = None
        if hasattr(self, attrname):
            result = getattr(self, attrname)(node, required_type=required_type, is_rvalue=is_rvalue)
        else:
            print('not supported: %s' % t)
            result = self.BV(0)

        # cast to desired type
        if required_type:
            result = self.cast(result, required_type)

        assert(required_type == None or get_type(result) == required_type)
        return result

    def visit_Name(self, node, required_type, is_rvalue=True):
        """ make new symbol """
        var_name = self.ssa_current_identifier(node.id)
        if not is_rvalue:
            var_name = self.ssa_advance_identifier(node.id)

        return self.make_variable(var_name, self.int_type)

    def visit_Constant(self, node, required_type, **params):
        match required_type, node.n:
            case self.int_type, int():
                result = self.BV(node.n)
            case self.bool_type, int():
                result = self.Bool(bool(node.n != 0))
            case None, int():
                result = self.BV(node.n)
            # case str():
                # result = types[str](node.n)
            case self.int_type, _:
                result = self.BV(0)
            case self.bool_type, _:
                result = self.Bool(False)
            case None, _:
                result = self.BV(0)
            case _:
                result = self.BV(node.n)
        return result

    def visit_Subscript(self, node, required_type, is_rvalue=False):
        var_name = '%s[%s]' % (node.value.id, node.slice.value)
        name = self.ssa_current_identifier(var_name)
        if not is_rvalue:
            name = self.ssa_advance_identifier(var_name)

        return self.make_variable(name, self.int_type)

    def visit_UnaryOp(self, node, **params):
        operand = self.visit(node.operand)
        if isinstance(node.op, ast.Not):
            match get_type(operand):
                case self.bool_type:
                    result = Not(operand)
                case self.int_type:
                    result = Equals(operand, self.BV(0))
        elif isinstance(node.op, ast.USub):
            result = BVNeg(operand)
        elif isinstance(node.op, ast.UAdd):
            result = operand
        elif isinstance(node.op, ast.Invert):
            result = BVNot(operand)
        else:
            raise NotImplementedError("Operator %s is not implemented!" % node.op)

        return result

    def visit_BoolOp(self, node, required_type, **params):
        left_result = self.visit(node.values[0], required_type=self.bool_type)
        right_result = self.visit(node.values[1], required_type=self.bool_type)

        result = None
        match node.op:
            case ast.And():
                result = And(left_result, right_result)
            case ast.Or():
                result = Or(left_result, right_result)
            case _:
                raise NotImplementedError("Operator %s is not implemented!" % op)

        assert get_type(result) == self.bool_type
        return result

    def visit_Compare(self, node, required_type, **params):
        left_result = self.visit(node.left)
        right_result = self.visit(node.comparators[0], required_type=get_type(left_result))
        ltype = get_type(left_result)
        assert get_type(left_result) == get_type(right_result)

        op = node.ops[0]
        result = None
        match op:
            case ast.Eq():
                result = self.make_equality(left_result, right_result)
            case ast.Gt():
                result = BVSGT(left_result, right_result)
            case ast.GtE():
                result = BVSGE(left_result, right_result)
            case ast.Lt():
                result = BVSLT(left_result, right_result)
            case ast.LtE():
                result = BVSLE(left_result, right_result)
            case ast.NotEq():
                result = Not(self.make_equality(left_result, right_result))
            case _:
                raise NotImplementedError("Operator %s is not implemented!" % op)

        assert get_type(result) == self.bool_type
        return result

    def visit_Return(self, node, required_type, **params):
        if required_type is None:
            required_type = self.int_type
        if node.value:
            right_result = self.visit(node.value, required_type)
            return self.make_equality(self.make_variable('__ret', required_type), right_result)
        return self.BV(1)

    def visit_Call(self, node, required_type, **params):
        if required_type is None:
            required_type = self.int_type
        if hasattr(self.instruction, 'target'):
            left  = self.make_variable(self.ssa_advance_identifier(self.instruction.target), self.int_type)
            right = self.make_variable(self.ssa_current_identifier('__ret'), self.int_type)
            return self.make_equality(left, right)
        return self.BV(1)
               

    def visit_Assign(self, node, **params):
        assert len(node.targets) == 1
        assert isinstance(node.targets[0], ast.Name), node.targets[0]

        result = None
        match node.value:
            case ast.List():
                assert isinstance(node.targets[0], ast.Name)
                name = node.targets[0].id
            
                clauses = []
                for i, expr in enumerate(node.value.elts):
                    val = self.visit(expr)

                    if val is not None:
                        var_name = '%s[%s]' % (name, i)
                        self.ssa_advance_index(name)
                        self.store_type(name, get_type(val))
                        clauses.append(self.make_equality(self.make_variable(var_name, self.int_type), val))
                result = And(clauses), self.int_type

            case ast.Name() | ast.Num() | ast.Constant() | ast.Subscript() | ast.BinOp() | ast.UnaryOp() | ast.Compare() | ast.BoolOp():
                right_result = self.visit(node.value, required_type=self.int_type)
                left_result = self.visit(node.targets[0], required_type=self.int_type, is_rvalue=False)

                result = self.make_equality(left_result, right_result)
                assert get_type(left_result) == self.int_type

            case ast.Call():
                right_result = self.make_variable('__ret', required_type=self.int_type)
                left_result = self.visit(node.targets[0], required_type=self.int_type, is_rvalue=False)
                result = self.make_equality(left_result, right_result)
                assert get_type(left_result) == self.int_type

            case _:
                print(type(node.value))
                raise NotImplementedError()

        return result

    def visit_BinOp(self, node, **params):
        left_result = self.visit(node.left)
        right_result = self.visit(node.right, required_type=get_type(left_result))
        assert get_type(left_result) == get_type(right_result) == self.int_type

        op = node.op
        result = None
        match op:
            case ast.Add():      result = BVAdd(left_result, right_result)
            case ast.Sub():      result = BVMinus(left_result, right_result)
            case ast.Mult():     result = BVMul(left_result, right_result)
            case ast.Div():      result = BVSDiv(left_result, right_result)  # TODO: make Real
            case ast.FloorDiv(): result = BVSDiv(left_result, right_result)
            case ast.Mod():      result = BVURem(left_result, right_result)
            case ast.Pow():      result = BVPow(left_result, right_result)
            case ast.LShift():   result = BVAShl(left_result, right_result)
            case ast.RShift():   result = BVAShr(left_result, right_result)
            case ast.BitOr():    result = BVOr(left_result, right_result)
            case ast.BitXor():   result = BVXor(left_result, right_result)
            case ast.BitAnd():   result = BVAnd(left_result, right_result)
            case _:
                raise NotImplementedError("Operator %s is not implemented!" % op)

        return result






================================================
File: pycpa/analyses/LocationCPA.py
================================================
#!/bin/env/python

from pycpa.cpa import CPA
from pycpa.cpa import MergeSepOperator, StopSepOperator, AbstractState, TransferRelation

from pycpa.cfa import CFANode, CFAEdge, InstructionType

from typing import Collection

# ### LocationCPA
# 
# We will implement a CPA $\mathbb{L}$ that tracks the current location in the program,
# which is called *LocationCPA*.
# 
# #### Task 5: Implementing transfer relation and stop operator of LocationCPA (6 points)
# 
# We will implement the transfer relation, which returns the successor location,
# and the stop operator, which returns true if a location has been explored in the reached set.
# (Note that, for the merge operator, we use the default merge-sep operator implemented above.)

# In[14]:

# LocationCPA.py
class LocationState(AbstractState):
    def __init__(self, node: CFANode):
        self.location = node

    # NEW ---------------------------------------------------------------- #
    def is_target(self) -> bool:
        """The state is a target iff the CFA node was tagged is_error=True."""
        return getattr(self.location, "is_error", False)
    # -------------------------------------------------------------------- #

    def __str__(self):
        return f"@{self.location.node_id}"

    def __eq__(self, other):
        return self.location == other.location

    def __hash__(self):
        return hash(self.location)


class LocationTransferRelation(TransferRelation):

    def get_abstract_successors(self, predecessor: LocationState) -> Collection[LocationState]:
        return [
            LocationState(edge.successor) 
            for edge in predecessor.location.leaving_edges 
            if edge.kind is not InstructionType.CALL
        ] + [
            LocationState(edge.instruction.location) 
            for edge in predecessor.location.leaving_edges 
            if edge.kind is InstructionType.CALL
        ]

    def get_abstract_successors_for_edge(self, predecessor: LocationState, edge: CFAEdge) -> Collection[LocationState]:
        kind = edge.instruction.kind
        if kind == InstructionType.CALL:
            return [LocationState(edge.instruction.location)]
        return [LocationState(edge.successor)]


class LocationStopOperator(StopSepOperator):
    def __init__(self):
        return StopSepOperator.__init__(self, LocationState.__eq__)


class LocationCPA(CPA):
    def __init__(self, cfa_root: CFANode):
        self.root = cfa_root

    def get_initial_state(self):
        return LocationState(self.root)

    def get_stop_operator(self):
        return LocationStopOperator()

    def get_merge_operator(self):
        return MergeSepOperator()

    def get_transfer_relation(self):
        return LocationTransferRelation()






================================================
File: pycpa/analyses/PredAbsCEGAR.py
================================================
# #!/usr/bin/env python3
# """
# Predicate-Abstraction CEGAR driver for pycpa
# ===========================================

# This module builds  LocationCPA × PredAbsCPA, runs the standard
# work-list algorithm, and refines the global predicate precision π
# until it

#     • proves SAFE          → returns "TRUE"
#     • finds a real bug     → returns "FALSE"
#     • exhausts its budget  → returns "UNKNOWN"

# No other files need to change.
# """

# from __future__ import annotations
# from typing import List, Set, Tuple

# import sys
# from pysmt.fnode import FNode
# from pysmt.shortcuts import TRUE

# from pycpa.cfa import CFANode
# from pycpa.analyses.LocationCPA      import LocationCPA
# from pycpa.analyses.PredAbsCPA       import PredAbsCPA
# from pycpa.analyses.PredAbsPrecision import PredAbsPrecision
# from pycpa.analyses.CompositeCPA     import CompositeCPA
# from pycpa.analyses.ARGCPA           import ARGCPA
# from pycpa.cpaalgorithm              import CPAAlgorithm, Status

# from pycpa.refinement import cegar_helper  # is_path_feasible / refine_precision

# # --------------------------------------------------------------------------- #
# # INTERNAL – one run under a *fixed* precision                                #
# # --------------------------------------------------------------------------- #
# def _analyse(entry: CFANode,
#              precision: Set[FNode],
#              task, specs,
#              arg_cap: int
#             ) -> Tuple[Status, CPAAlgorithm]:
#     """
#     Run work-list algorithm once and return (Status, algo_instance).
#     If ARG exceeds arg_cap nodes → return Status.TIMEOUT.
#     """
#     cpa   = ARGCPA(CompositeCPA([LocationCPA(entry),
#                                  PredAbsCPA(precision)]))

#     init = cpa.get_initial_state()
#     reached, wl = {init}, {init}

#     algo = CPAAlgorithm(cpa, task, type("R", (), {})(), specs)
#     algo.run(reached, wl)          # ← only the two mandatory args

#     # manual budget check
#     if len(reached) >= arg_cap:
#         algo.result.status = Status.TIMEOUT

#     return algo.result.status, algo

# # --------------------------------------------------------------------------- #
# # PUBLIC – CEGAR loop                                                         #
# # --------------------------------------------------------------------------- #
# def run_cegar(entry: CFANode,
#               cfa_roots: List[CFANode],
#               task, specification,
#               *, max_refinements: int = 12,
#                  arg_node_cap:   int = 50_000,
#                  verbose: bool      = False) -> str:

#     π = PredAbsPrecision.from_cfa(cfa_roots).predicates

#     for k in range(max_refinements):
#         if verbose:
#             print(f"\n[CEGAR {k:02d}]  |π| = {len(π)}")

#         status, algo = _analyse(entry, π, task, specification, arg_node_cap)

#         # 0) proof succeeded
#         if status == Status.OK:
#             return "TRUE"
#         # 1) only TIMEOUT is treated as UNKNOWN
#         if status == Status.TIMEOUT:
#             return "UNKNOWN"
#         # (we deliberately do NOT bail out on Status.ERROR here,
#         #  so that we can extract the abstract counterexample)

#         # 2) extract abstract counterexample
#         # print("[DEBUG PredAbsCEGAR] retrieving abstract_cex_edges from CPAAlgorithm")
#         if not hasattr(algo, "abstract_cex_edges"):
#             raise AttributeError("run_cegar: CPAAlgorithm has no `abstract_cex_edges`")
#         cex_edges = algo.abstract_cex_edges
#         # print(f"[DEBUG PredAbsCEGAR] abstract cex path = {cex_edges}")

#         # 3) check feasibility
#         if cegar_helper.is_path_feasible(cex_edges):
#             return "FALSE"

#         # 4) not feasible → refine π and loop
#         π = cegar_helper.refine_precision(π, cex_edges)
#     # refinements exhausted
#     return "UNKNOWN"

# # PredAbsCEGAR.py

# from typing import List, Set
# from pycpa.cfa import CFANode
# from pycpa.analyses.PredAbsPrecision import PredAbsPrecision
# from pycpa.refinement import cegar_helper
# from pycpa.analyses.LocationCPA import LocationCPA
# from pycpa.analyses.PredAbsCPA     import PredAbsCPA
# from pycpa.analyses.CompositeCPA    import CompositeCPA
# from pycpa.analyses.ARGCPA          import ARGCPA
# from pycpa.cpaalgorithm             import CPAAlgorithm, Status

# def run_cegar(entry: CFANode,
#               cfa_roots: List[CFANode],
#               task, specification,
#               *, max_refinements: int = 12,
#                  arg_node_cap:   int = 50_000,
#                  verbose: bool      = False) -> str:

#     # 0) initialize precision π from all boolean atoms in the CFA
#     π = PredAbsPrecision.from_cfa(cfa_roots).predicates

#     # 1) perform up to max_refinements CEGAR iterations
#     for k in range(max_refinements):
#         if verbose:
#             print(f"\n[CEGAR {k:02d}]  |π| = {len(π)}")

#         # run one ARGCPA pass under the current π
#         status, algo = _analyse(entry, π, task, specification, arg_node_cap)

#         # 2) if SAFE, we’re done
#         if status == Status.OK:
#             return "TRUE"

#         # 3) if an abstract error was detected, bail out immediately
#         if status == Status.ERROR:
#             return "FALSE"

#         # 4) only TIMEOUT is treated as UNKNOWN
#         if status == Status.TIMEOUT:
#             return "UNKNOWN"

#         # 5) extract the abstract counterexample path
#         # print("[DEBUG PredAbsCEGAR] retrieving abstract_cex_edges from CPAAlgorithm")
#         if not hasattr(algo, "abstract_cex_edges"):
#             raise AttributeError("run_cegar: CPAAlgorithm lacks `abstract_cex_edges`")
#         cex_edges = algo.abstract_cex_edges
#         # print(f"[DEBUG PredAbsCEGAR] abstract cex path = {cex_edges}")

#         # 6) check concrete feasibility; if real bug, return FALSE
#         if cegar_helper.is_path_feasible(cex_edges):
#             return "FALSE"

#         # 7) spurious → refine precision π and continue
#         π = cegar_helper.refine_precision(π, cex_edges)

#     # refinement budget exhausted
#     return "UNKNOWN"


#!/usr/bin/env python3
"""
PredAbsCEGAR.py
===============

Predicate-abstraction **C**ounter-**E**xample-**G**uided **A**bstraction
**R**efinement driver for *pyCPA*.

The module is self-contained: import it, call ``run_cegar`` with the CFA
entry node, the list of CFA roots, the verification *task* object and the
chosen *specification* CPA(s); it returns the usual verdict string
``"TRUE"``, ``"FALSE"`` or ``"UNKNOWN"``.

Key design decisions
--------------------
* **ARGCPA** wraps a product of
  ``LocationCPA × PredAbsCPA(π)`` – the precision π is refined across
  iterations.
* On every iteration we run the normal work-list algorithm
  (``CPAAlgorithm``).  The algorithm records an *abstract* error path
  (list of ``CFAEdge`` objects); the driver asks the SMT-based helper
  ``cegar_helper.is_path_feasible`` whether the path is *concrete*.
* Only a *concrete* error path terminates the loop with the verdict
  ``"FALSE"`` – otherwise we refine π and try again.
* The loop stops when:  
  ─ the program is proven safe   → ``"TRUE"``  
  ─ the refinement budget is used up or the ARG grows too large   → ``"UNKNOWN"``


------------------------------------------------------------------------
"""

from __future__ import annotations

from typing import List, Set, Tuple

from pysmt.fnode import FNode
from pysmt.shortcuts import TRUE  # convenience constant

from pycpa.cfa                       import CFANode
from pycpa.analyses.LocationCPA      import LocationCPA
from pycpa.analyses.PredAbsCPA       import PredAbsCPA
from pycpa.analyses.PredAbsPrecision import PredAbsPrecision
from pycpa.analyses.CompositeCPA     import CompositeCPA
from pycpa.analyses.ARGCPA           import ARGCPA
from pycpa.cpaalgorithm              import CPAAlgorithm, Status

# refinement helpers (SMT-based feasibility + predicate generation)
from pycpa.refinement import cegar_helper


# --------------------------------------------------------------------------- #
# internal: run **one** analysis under a *fixed* predicate precision π        #
# --------------------------------------------------------------------------- #
def _analyse_once(entry        : CFANode,
                  π            : Set[FNode],
                  task,
                  specs,
                  arg_cap      : int
                  ) -> Tuple[Status, CPAAlgorithm]:
    """
    Build LocationCPA × PredAbsCPA(π), execute the work-list algorithm,
    return the resulting *status* and the *CPAAlgorithm* instance (for the
    stored abstract counter-example, reached set size, …).

    If the ARG grows beyond *arg_cap* nodes we treat it as a timeout so
    the caller can translate that to the verdict “UNKNOWN”.
    """
    composite_cpa  = CompositeCPA([LocationCPA(entry), PredAbsCPA(π)])
    cpa            = ARGCPA(composite_cpa)

    init     = cpa.get_initial_state()
    reached  = {init}
    waitlist = {init}

    algo = CPAAlgorithm(cpa, task, type("Res", (), {})(), specs)
    algo.run(reached, waitlist)

    if len(reached) >= arg_cap:
        algo.result.status = Status.TIMEOUT

    return algo.result.status, algo


# --------------------------------------------------------------------------- #
# public: full CEGAR loop                                                     #
# --------------------------------------------------------------------------- #
def run_cegar(entry              : CFANode,
              cfa_roots          : List[CFANode],
              task,
              specification,
              *,
              max_refinements    : int  = 12,
              arg_node_cap       : int  = 50_000,
              verbose            : bool = False
              ) -> str:
    """
    Execute the standard CEGAR loop.

    Parameters
    ----------
    entry
        CFA entry node of the *main* procedure.
    cfa_roots
        All CFA roots (one per Python function) – used to mine predicates.
    task
        The *Task* object created by the CLI front-end (iteration limits).
    specification
        List of specification CPA names (e.g. ``["ReachSafety"]``).
    max_refinements, arg_node_cap, verbose
        Tuning parameters; defaults suffice for the benchmark suite.

    Returns
    -------
    str
        ``"TRUE"``, ``"FALSE"`` or ``"UNKNOWN"`` (SV-COMP conventions).
    """
    # 0)  initial predicate precision  π₀  =  all Boolean atoms in the CFA
    π = PredAbsPrecision.from_cfa(cfa_roots).predicates
    if not π:
        π = {TRUE()}            # guarantee π ≠ ∅ to placate SMT encodings

    # --- main refinement loop ---------------------------------------------
    for k in range(max_refinements):
        if verbose:
            print(f"\n[CEGAR {k:02d}]  |π| = {len(π)}")

        status, algo = _analyse_once(entry, π, task,
                                     specification, arg_node_cap)

        # 1)  SUCCESS – proven safe
        if status is Status.OK:
            return "TRUE"

        # 2)  gave up (ARG too large or user timeout)
        if status is Status.TIMEOUT:
            return "UNKNOWN"

        # 3)  all other statuses should come with an abstract cex
        cex_edges = getattr(algo, "abstract_cex_edges", None)
        if not cex_edges:
            # defensive: unexpected state => declare UNKNOWN
            if verbose:
                print("[WARN]   no abstract counter-example returned")
            return "UNKNOWN"

        # optional pretty print
        if verbose:
            print("  abstract counter-example:",
                  " ➔ ".join(f"{e.instruction}" for e in cex_edges))

        # 4)  FEASIBILITY CHECK
        if cegar_helper.is_path_feasible(cex_edges):
            return "FALSE"      # real bug – stop!

        # 5)  spurious – REFINE  π  and iterate
        π = cegar_helper.refine_precision(π, cex_edges)

    # 6)  refinement budget exhausted
    return "UNKNOWN"



================================================
File: pycpa/analyses/PredAbsCPA.py
================================================
#!/usr/bin/env python
"""
Predicate-abstraction CPA with Cartesian abstraction and SSA support.
"""

from __future__ import annotations
import copy
import ast
import sys
from typing import List, Set, Dict

from pysmt.shortcuts import And, Not, TRUE, FALSE, is_sat
import pysmt.fnode as fnode
from pysmt.exceptions import SolverReturnedUnknownResultError

from pycpa.cfa import InstructionType, CFAEdge
from pycpa.cpa import CPA, AbstractState, TransferRelation, StopSepOperator, MergeSepOperator

from pycpa.analyses.PredAbsPrecision import PredAbsPrecision

# --------------------------------------------------------------------------- #
# Abstract State
# --------------------------------------------------------------------------- #
class PredAbsState(AbstractState):
    def __init__(self, other: 'PredAbsState' | None = None) -> None:
        if other:
            self.predicates: Set[fnode.FNode] = set(other.predicates)
            self.ssa_indices: Dict[str, int] = copy.deepcopy(other.ssa_indices)
        else:
            self.predicates = set()
            self.ssa_indices = {}

    def subsumes(self, other: 'PredAbsState') -> bool:
        return other.predicates.issubset(self.predicates)

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, PredAbsState) and
            self.predicates == other.predicates and
            self.ssa_indices == other.ssa_indices
        )

    def __hash__(self) -> int:
        return hash(frozenset(self.predicates)) ^ hash(frozenset(self.ssa_indices.items()))

    def __str__(self) -> str:
        return '{' + ', '.join(str(p) for p in self.predicates) + '}'

# --------------------------------------------------------------------------- #
# Transfer Relation
# --------------------------------------------------------------------------- #
class PredAbsTransferRelation(TransferRelation):
    """
    Cartesian abstraction:
      succ.predicates = { t ∈ π |  SP(edge, ∧preds(pre)) ⇒ t }
    """
    def __init__(self, precision: Set[fnode.FNode]) -> None:
        self.precision = precision

    @staticmethod
    def _implied_predicates(ctx: Set[fnode.FNode],
                            trans: fnode.FNode,
                            precision: Set[fnode.FNode]) -> Set[fnode.FNode]:
        phi = And(list(ctx)) if ctx else TRUE()
        phi = And(phi, trans)

        implied: Set[fnode.FNode] = set()
        for p in precision:
            try:
                sat = is_sat(And(phi, Not(p)))
            except SolverReturnedUnknownResultError:
                sat = True
            if not sat:                 # UNSAT ⇒ φ ⇒ p
                implied.add(p)
        
        # ------------------------------------------------------------ #
        #  VERBOSE LOGGING – print each *new* predicate set once
        # ------------------------------------------------------------ #
        main = sys.modules.get("__main__")
        if getattr(main, "args", None) and getattr(main.args, "verbose", False):
            seen = getattr(PredAbsCPA, "_seen_predsets", set())
            key  = frozenset(implied)
            if key not in seen:
                seen.add(key)
                PredAbsCPA._seen_predsets = seen
                print("New predicate set:", '{' + ', '.join(map(str, implied)) + '}')
        # ------------------------------------------------------------ #

        return implied

    def get_abstract_successors(self, predecessor: PredAbsState) -> List[PredAbsState]:
        raise NotImplementedError

    def get_abstract_successors_for_edge(self,
                                         predecessor: PredAbsState,
                                         edge: CFAEdge
                                        ) -> List[PredAbsState]:
        # 1) Copy SSA indices locally
        ssa_idx = copy.deepcopy(predecessor.ssa_indices)

        # 2) Compute strongest‐post condition (trans)
        kind = edge.instruction.kind
        if   kind == InstructionType.STATEMENT:
            trans = PredAbsPrecision.ssa_from_assign(edge, ssa_indices=ssa_idx)
        elif kind == InstructionType.ASSUMPTION:
            trans = PredAbsPrecision.ssa_from_assume(edge, ssa_indices=ssa_idx)
        elif kind == InstructionType.CALL:
            trans = PredAbsPrecision.ssa_from_call(edge, ssa_indices=ssa_idx)
        elif kind == InstructionType.REACH_ERROR:
            # **special case**: hitting an error-edge → FALSE
            trans = FALSE()
        else:
            trans = TRUE()

        # 3) If this is truly unsatisfiable (i.e. error-edge), preserve it
        if trans.is_false():
            succ = PredAbsState()
            succ.ssa_indices = ssa_idx
            succ.predicates  = {trans}
            return [succ]

        # 4) Otherwise do Cartesian abstraction
        new_preds = self._implied_predicates(
            predecessor.predicates,
            trans,
            self.precision
        )
        succ = PredAbsState()
        succ.ssa_indices = ssa_idx
        succ.predicates  = new_preds
        return [succ]

# --------------------------------------------------------------------------- #
# CPA wrapper
# --------------------------------------------------------------------------- #
class PredAbsCPA(CPA):
    def __init__(self, initial_precision) -> None:
        self.precision = (
            initial_precision.predicates
            if hasattr(initial_precision, "predicates")
            else set(initial_precision)
        )

    def get_initial_state(self) -> PredAbsState:
        return PredAbsState()

    def get_stop_operator(self) -> StopSepOperator:
        return StopSepOperator(PredAbsState.subsumes)

    def get_merge_operator(self) -> MergeSepOperator:
        return MergeSepOperator()

    def get_transfer_relation(self) -> TransferRelation:
        return PredAbsTransferRelation(self.precision)





================================================
File: pycpa/analyses/PredAbsPrecision.py
================================================
#!/usr/bin/env python3
"""
Predicate Abstraction – Precision object + SSA helpers (final version).

* Precise translation for names, literals, all basic arithmetic,
  Boolean connectors, comparisons, unary ops.
* Unknown literals become fresh symbolic integers (sound over-approx.).
* PredAbsPrecision is **iterable** (behaves like a set of predicates).
"""

from __future__ import annotations
import ast, hashlib
from typing import Dict, Iterable, Set, List

from pysmt.shortcuts import (
    And, Or, Not, Equals, LT, LE, GT, GE,
    Int, Symbol, Div, TRUE, FALSE
)
from pysmt.typing  import INT
from pysmt.fnode   import FNode

# --------------------------------------------------------------------------- #
#  imports that work in- and outside the package                              #
# --------------------------------------------------------------------------- #
try:
    from pycpa.cfa import InstructionType, CFAEdge, CFANode
except ImportError:
    from cfa import InstructionType, CFAEdge, CFANode

# --------------------------------------------------------------------------- #
#  SSA helpers                                                                #
# --------------------------------------------------------------------------- #
def _ssa(var: str, idx: int) -> FNode:
    return Symbol(f"{var}#{idx}", INT)

def _next(var: str, ssa: Dict[str, int]) -> int:
    ssa[var] = ssa.get(var, 0) + 1
    return ssa[var]

# --------------------------------------------------------------------------- #
#  Expression → SMT (covers all needed cases)                                 #
# --------------------------------------------------------------------------- #
def _expr2smt(node: ast.AST, ssa: Dict[str, int]) -> FNode:
    def _bool(t: FNode) -> FNode:
        return t if t.get_type().is_bool_type() else Not(Equals(t, Int(0)))

    match node:
        # identifiers / literals ---------------------------------------------
        case ast.Name(id=v):
            return _ssa(v, ssa.get(v, 0))

        case ast.Constant(value=v):
            if isinstance(v, bool): return TRUE() if v else FALSE()
            if isinstance(v, int):  return Int(v)
            # other constant → fresh INT
            h = hashlib.md5(repr(v).encode()).hexdigest()[:8]
            return Symbol(f"const_{h}", INT)

        # arithmetic ----------------------------------------------------------
        case ast.BinOp(left=l, op=ast.Add(),  right=r):
            return _expr2smt(l, ssa) + _expr2smt(r, ssa)
        case ast.BinOp(left=l, op=ast.Sub(),  right=r):
            return _expr2smt(l, ssa) - _expr2smt(r, ssa)
        case ast.BinOp(left=l, op=ast.Mult(), right=r):
            return _expr2smt(l, ssa) * _expr2smt(r, ssa)
        case ast.BinOp(left=l, op=ast.Div(),  right=r):
            return Div(_expr2smt(l, ssa), _expr2smt(r, ssa))
        case ast.BinOp(left=l, op=ast.FloorDiv(), right=r):
            return Div(_expr2smt(l, ssa), _expr2smt(r, ssa))
        case ast.BinOp(left=l, op=ast.Mod(), right=r):
            a, b = _expr2smt(l, ssa), _expr2smt(r, ssa)
            return a - b * Div(a, b)

        # Boolean connectives -------------------------------------------------
        case ast.BoolOp(op=ast.And(), values=vs):
            return And([_bool(_expr2smt(v, ssa)) for v in vs])
        case ast.BoolOp(op=ast.Or(),  values=vs):
            return Or ([_bool(_expr2smt(v, ssa)) for v in vs])

        # unary ---------------------------------------------------------------
        case ast.UnaryOp(op=ast.Not(),  operand=o):
            return Not(_bool(_expr2smt(o, ssa)))
        case ast.UnaryOp(op=ast.USub(), operand=o):
            return -_expr2smt(o, ssa)

        # comparisons ---------------------------------------------------------
        case ast.Compare(left=l, ops=ops, comparators=comps):
            lhs, conjs = _expr2smt(l, ssa), []
            for op, rhs_ast in zip(ops, comps):
                rhs = _expr2smt(rhs_ast, ssa)
                conjs.append({
                    ast.Lt: LT, ast.LtE: LE,
                    ast.Gt: GT, ast.GtE: GE,
                    ast.Eq: Equals,
                    ast.NotEq: lambda a,b: Not(Equals(a,b))
                }[type(op)](lhs, rhs))
                lhs = rhs
            return And(conjs)
        
        # --------------------------------------------------------------
        # unknown function call -> fresh nondet INT
        # --------------------------------------------------------------
        case ast.Call(func=ast.Name(id=fname), args=args):
            h = hashlib.md5(("call_" + fname + str(len(args))).encode()).hexdigest()[:8]
            return Symbol(f"call_{fname}_{h}", INT)


        # fallback ------------------------------------------------------------
        case _:
            raise NotImplementedError(f"expr→SMT for {ast.dump(node)}")

# --------------------------------------------------------------------------- #
#  Precision object (iterable like a set)                                     #
# --------------------------------------------------------------------------- #
class PredAbsPrecision(Iterable):
    def __init__(self, preds: Set[FNode] | None = None):
        self.predicates: Set[FNode] = set(preds or {TRUE(), FALSE()})

    # iterable / container protocol
    def __iter__(self):        return iter(self.predicates)
    def __contains__(self, p): return p in self.predicates
    def __len__(self):         return len(self.predicates)

    # ------------------------------------------------------------------ #
    #  (NEW) SSA for CALL edges:  copy actuals → formals, fresh ret var  #
    # ------------------------------------------------------------------ #
    @staticmethod
    def ssa_from_call(edge: CFAEdge, ssa=None, ssa_indices=None) -> FNode:
        """
        Build an SSA formula for a function-call edge.

        • For every (formal, actual) pair produce      formal#k+1  =  <actual>
        • If the instruction contains  instr.ret_var   copy return value:
              lhs_var#k+1  =  ret_sym
          (ret_sym is fresh, unconstrained INT)
        """
        ssa = ssa if ssa is not None else (ssa_indices or {})
        instr = edge.instruction

        # safeguard: if we lack meta-data, over-approximate with TRUE
        if not hasattr(instr, "param_names") or not hasattr(instr, "arg_names"):
            return TRUE()

        conjuncts = []

        # 1. map each parameter
        for formal, actual in zip(instr.param_names, instr.arg_names):
            lhs = _ssa(formal, _next(formal, ssa))
            rhs = _expr2smt(ast.Name(id=actual, ctx=ast.Load()), ssa)
            conjuncts.append(Equals(lhs, rhs))

        # 2. optional return-value assignment  x = f(...)
        if hasattr(instr, "ret_var") and instr.ret_var:
            ret_sym = Symbol(f"ret_{instr.declaration.name}", INT)
            lhs = _ssa(instr.ret_var, _next(instr.ret_var, ssa))
            conjuncts.append(Equals(lhs, ret_sym))

        return And(conjuncts) if conjuncts else TRUE()

        
    @staticmethod
    def ssa_from_assert(edge: CFAEdge, ssa=None, ssa_indices=None) -> FNode:
        """
        Handle Python 'assert' statements by extracting the test expression
        and translating it into an SMT predicate for refinement.
        """
        # Retrieve the AST Assert node and its test
        assert_node = edge.instruction.expression
        test_expr   = assert_node.test

        # Build/update SSA indices map if not provided
        ssa_map = ssa if ssa is not None else (ssa_indices or {})
        # Convert the test expression to an SMT formula
        return _expr2smt(test_expr, ssa_map)

    @staticmethod
    def ssa_from_raise(edge: CFAEdge, ssa=None, ssa_indices=None) -> FNode:
        # print(f"[DEBUG PredAbsPrecision] ssa_from_raise: kind={edge.instruction.kind}, expr={edge.instruction.expression!r}")
        return FALSE()

    @staticmethod
    def ssa_from_assign(edge: CFAEdge, ssa=None, ssa_indices=None) -> FNode:
        expr = getattr(edge.instruction, 'expression', None)
        # print(f"[DEBUG PredAbsPrecision] ssa_from_assign: kind={edge.instruction.kind}, expr={expr!r}")

        # 1) if this is a `raise`, mark as infeasible continuation
        if isinstance(expr, ast.Raise):
            # print("  → Detected Raise; returning FALSE()")
            return FALSE()

        # 2) standard assignment
        if isinstance(expr, ast.Assign):
            ssa_map = ssa if ssa is not None else (ssa_indices or {})
            var     = expr.targets[0].id
            lhs     = _ssa(var, _next(var, ssa_map))
            rhs     = _expr2smt(expr.value, ssa_map)
            # print(f"  → Assign {var}#{ssa_map[var]} = {rhs}")
            return Equals(lhs, rhs)

        # 3) everything else is a no-op
        return TRUE()

    @staticmethod
    def ssa_from_assume(edge: CFAEdge, ssa=None, ssa_indices=None) -> FNode:
        # Handles both 'assert' and 'if' conditions
        expr = edge.instruction.expression
        ssa_map = ssa or (ssa_indices or {})
        phi = _expr2smt(expr, ssa_map)
        if getattr(edge.instruction, 'negated', False):
            return Not(phi)
        return phi
    
    @staticmethod
    def ssa_from_raise(edge: CFAEdge, ssa=None, ssa_indices=None) -> FNode:
        """
        Handle Python 'raise' by mapping it to FALSE(), marking an error path.
        """
        # print(f"[DEBUG PredAbsPrecision] ssa_from_raise on edge {edge}")
        return FALSE()


    @staticmethod
    def ssa_from_call(edge: CFAEdge, ssa=None, ssa_indices=None) -> FNode:
        # Inline the original call handler logic
        ssa_map = ssa if ssa is not None else (ssa_indices or {})
        instr = edge.instruction
        if not hasattr(instr, "param_names") or not hasattr(instr, "arg_names"):
            return TRUE()
        conjuncts = []
        for formal, actual in zip(instr.param_names, instr.arg_names):
            lhs = _ssa(formal, _next(formal, ssa_map))
            rhs = _expr2smt(ast.Name(id=actual, ctx=ast.Load()), ssa_map)
            conjuncts.append(Equals(lhs, rhs))
        if hasattr(instr, "ret_var") and instr.ret_var:
            ret_sym = Symbol(f"ret_{instr.declaration.name}", INT)
            lhs = _ssa(instr.ret_var, _next(instr.ret_var, ssa_map))
            conjuncts.append(Equals(lhs, ret_sym))
        return And(conjuncts) if conjuncts else TRUE()

    @staticmethod
    def from_cfa_edge(edge: CFAEdge) -> FNode | None:
        expr = getattr(edge.instruction, 'expression', None)
        # print(f"[DEBUG PredAbsPrecision] from_cfa_edge: kind={edge.instruction.kind}, expr={expr!r}")

        # Python `assert` → assume
        if isinstance(expr, ast.Assert):
            # print("  → mining assert condition")
            return PredAbsPrecision.ssa_from_assume(edge, {}, {})

        # explicit CFA assume edge
        if edge.instruction.kind == InstructionType.ASSUMPTION:
            # print("  → mining an ASSUMPTION edge")
            return PredAbsPrecision.ssa_from_assume(edge, {}, {})

        # statements (assign or raise)
        if edge.instruction.kind == InstructionType.STATEMENT:
            if isinstance(expr, ast.Raise):
                # print("  → mining a Raise statement")
                return PredAbsPrecision.ssa_from_raise(edge, {}, {})
            else:
                # print("  → mining a STATEMENT edge")
                return PredAbsPrecision.ssa_from_assign(edge, {}, {})

        # function calls
        if edge.instruction.kind == InstructionType.CALL:
            # print("  → mining a CALL edge")
            return PredAbsPrecision.ssa_from_call(edge, {}, {})

        return None




    @staticmethod
    def from_cfa(roots: List[CFANode]) -> "PredAbsPrecision":
        preds: Set[FNode] = {TRUE(), FALSE()}
        todo, seen = list(roots), set()
        while todo:
            n = todo.pop()
            if n in seen: continue
            seen.add(n)
            for e in n.leaving_edges:
                f = PredAbsPrecision.from_cfa_edge(e)
                if f is not None and f.get_type().is_bool_type():
                    preds.update(f.get_atoms())
                todo.append(e.successor)
        return PredAbsPrecision(preds)
    
    def __str__(self): return '{' + ', '.join(map(str, self.predicates)) + '}'



================================================
File: pycpa/analyses/PropertyCPA.py
================================================
#!/usr/bin/env python

from pycpa.cpa import CPA, AbstractState, TransferRelation, MergeOperator, StopOperator, MergeSepOperator
from pycpa.cfa import InstructionType, CFAEdge

import ast

# ### PropertyCPA
# 
# In this part, we will write a CPA that checks for whether the function `reach_error` has been invoked on the explored path.
# The `__str__` method of the states of that CPA should mark each state as either `unsafe` or `safe`
# depending on whether this call has been reached or not.
# (You are on your own here, we will not give you any code to start with.
# You might want to create a visitor that checks for call nodes in the instructions and use that one in your transfer relation.)
# 
# #### Task 9: Implementing PropertyCPA (10 points)

# In[28]:


class PropertyState(AbstractState):
    def __init__(self, is_safe):
        self.safe = is_safe

    def subsumes(self, other):
        return other.safe == None or self.safe == other.safe

    def __eq__(self, other):
        return self.safe == other.safe

    def __hash__(self):
        return self.safe.__hash__()

    def __str__(self):
        if self.safe:
            return 'safe'
        else:
            return 'unsafe'



class FunctionCallVisitor(ast.NodeVisitor):
    def __init__(self, previous_state):
        self.state = previous_state

    def visit_Call(self, node):
        # if reach_error is called, update the state to unsafe
        if node.func.id == 'reach_error':
            self.state = PropertyState(False)

        return self.generic_visit(node)


class PropertyTransferRelation(TransferRelation):
    def get_abstract_successors(self, predecessor : PropertyState):
        raise NotImplementedError(
            "successors without edge not possible for Property Analysis!"
        )

    def get_abstract_successors_for_edge(self, predecessor : PropertyState, edge : CFAEdge):
        v = FunctionCallVisitor(predecessor)
        kind = edge.instruction.kind
        if kind == InstructionType.STATEMENT:
            v.visit(edge.instruction.expression)
            return [v.state]
        elif kind == InstructionType.ASSUMPTION:
            v.visit(edge.instruction.expression)
            return [v.state]
        elif kind == InstructionType.REACH_ERROR:
            return [PropertyState(False)]
        else:
            return [predecessor]


class PropertyStopOperator(StopOperator):
    def stop(self, e, reached):
        return not e.safe


class PropertyCPA(CPA):
    def get_initial_state(self):
        return PropertyState(True)

    def get_stop_operator(self):
        return PropertyStopOperator()

    def get_merge_operator(self):
        # simply use merge sep
        return MergeSepOperator()

    def get_transfer_relation(self):
        return PropertyTransferRelation()





================================================
File: pycpa/analyses/StackCPA.py
================================================
#!/usr/bin/env python

from pycpa.cpa import CPA, AbstractState, WrappedAbstractState, TransferRelation, MergeOperator, StopOperator
from pycpa.cfa import Graphable, CFAEdge, InstructionType
from pycpa.analyses import LocationState, ValueState

import ast
import astpretty
from graphviz import Digraph

import copy
from typing import Collection


class StackState(WrappedAbstractState):
    def __init__(self, stack, parent=None):
        self.stack = stack
        
    def __str__(self):
        if len(self.stack) > 0:
            if len(self.stack) > 2:
                stacks = '\n'.join(reversed([str(s) for s in self.stack[-3:]]))
                return f"{stacks}\n..."
            if len(self.stack) <= 2:
                stacks = '\n'.join(reversed([str(s) for s in self.stack]))
                return f"{stacks}"
        else:
            return f"..."

    def is_target(self):
        return hasattr(self.stack[-1], "is_target") and self.stack[-1].is_target()
    
    def wrapped(self):
        return WrappedAbstractState.unwrap(self.stack[-1])
    

class StackTransferRelation(TransferRelation):
    def __init__(self, wrapped_transfer_relation):
        self.wrapped_transfer_relation = wrapped_transfer_relation

    def get_abstract_successors(self, predecessor):
        raise NotImplementedError('successors without edge unsupported for stack')

    def get_abstract_successors_for_edge(self, predecessor : StackState, edge):
        states = [
            wrapped_successor
            for wrapped_successor in self.wrapped_transfer_relation.get_abstract_successors_for_edge(
                predecessor.stack[-1], edge
            )
        ]
        result = [StackState(copy.deepcopy(predecessor.stack)) for w in states]

        kind = edge.instruction.kind
        if kind == InstructionType.CALL:
            for i, wrapped_successor in enumerate(states):
                result[i].stack.append(wrapped_successor)

        elif kind == InstructionType.RETURN:
            for i, wrapped_successor in enumerate(states):
                if len(result[i].stack) < 2:
                    continue

                s = result[i].stack[-2]

                # advance instruction pointer 
                for w, p in zip(WrappedAbstractState.unwrap_fully(s), WrappedAbstractState.unwrap_fully(predecessor.stack[-2])):
                    if isinstance(p, LocationState):
                        w.location = p.location.leaving_edges[0].successor

                # write return value
                for w, p in zip(WrappedAbstractState.unwrap_fully(s), WrappedAbstractState.unwrap_fully(predecessor.stack[-1])):
                    if isinstance(p, ValueState):
                        if '__ret' in p.valuation:
                            # if target attribute is provided, directly write to that variable
                            if hasattr(edge.instruction, 'target'):
                                w.valuation[edge.instruction.target] = copy.copy(p.valuation['__ret'])
                            # otherwise, set __ret
                            else:
                                w.valuation['__ret'] = copy.copy(p.valuation['__ret'])

                result[i].stack.pop()
            return result

        for i, wrapped_successor in enumerate(states):
            result[i].stack[-1] = wrapped_successor

        assert isinstance(result, list)
        return result


class StackStopOperator(StopOperator):
    def __init__(self, wrapped_stop_operator):
        self.wrapped_stop_operator = wrapped_stop_operator

    def stop(self, e : StackState, reached : Collection[StackState]) -> StackState:
        return self.wrapped_stop_operator.stop(
            e.stack[-1], [eprime.stack[-1] for eprime in reached]
        )



class StackMergeOperator(MergeOperator):
    def __init__(self, wrapped_merge_operator):
        self.wrapped_merge_operator = wrapped_merge_operator

    def merge(self, state1, state2):
        return state2
        # # merge upper stack frame
        # wrapped_state1 = state1.stack[-1]
        # wrapped_state2 = state2.stack[-1]
        # upper_merge_result = self.wrapped_merge_operator.merge(wrapped_state1, wrapped_state2)

        # # merge stack by suffix-relation

        # if upper_merge_result == wrapped_state2:
        #     return state2
        # else:
        #     state2[-1] = upper_merge_result
        #     return state2




class StackCPA(CPA):
    def __init__(self, wrapped_cpa):
        self.wrapped_cpa = wrapped_cpa

    def get_initial_state(self):
        return StackState([self.wrapped_cpa.get_initial_state()])

    def get_stop_operator(self):
        return StackStopOperator(self.wrapped_cpa.get_stop_operator())

    def get_merge_operator(self):
        return StackMergeOperator(self.wrapped_cpa.get_merge_operator())

    def get_transfer_relation(self):
        return StackTransferRelation(self.wrapped_cpa.get_transfer_relation())



================================================
File: pycpa/analyses/ValueAnalysisCPA.py
================================================
#!/usr/bin/env python

from pycpa.cfa import InstructionType

from pycpa.cpa import CPA, AbstractState, TransferRelation, StopSepOperator, MergeSepOperator

import ast
import copy

import astunparse
import astpretty

# ### Value Analysis via ValueAnalysisCPA
# 
# To achieve a minimal value analysis,
# we will design a CPA that realizes constant propagation and
# a PropertyCPA that enables us to specify reachability by checking whether the function `reach_error` was called.
# 
# To test our implementation, we use the following two example programs:


# #### Task 8: Supporting arithmetic operators in value analysis (10 points)
# 
# To support value analysis, the transfer relation of our CPA needs to understand the semantics of the arithmetic operators, such as `+,-,*,/,>,==`.
# Below is a skeleton of how a CPA for value analysis can be constructed.
# The implementation of arithmetic operators is left as TODOs.
# We again use the visitor pattern for the implementation.
# 
# (5 points for the implementation in class `ValueExpressionVisitor`; 5 points for each test program. Note that we will have hidden programs that may require more support of the arithmetic operators.)

# In[23]:


class ValueState(AbstractState):
    def __init__(self, other=None):
        if other:
            self.valuation = copy.copy(other.valuation)
        else:
            self.valuation = dict()

    def subsumes(self, other):
        return all(
            [
                not key in self.valuation or self.valuation[key] == value
                for (key, value) in other.valuation.items()
            ]
        )

    def __eq__(self, other):
        return self.valuation == other.valuation

    def __hash__(self):
        return tuple(
            (k, v)
            for (k, v) in sorted(self.valuation.items(), key=lambda item: item[0])
        ).__hash__()

    def __str__(self):
        return "{%s}" % ",".join(
            ["->".join((k, str(v))) for (k, v) in self.valuation.items()]
        )


# In[24]:


class ValueExpressionVisitor(ast.NodeVisitor):
    def __init__(self, valuation):
        self.valuation = valuation
        self.lstack = list()
        self.rstack = list()

    def visit_Name(self, node):
        if isinstance(node.ctx, ast.Store):
            self.lstack.append(str(node.id))
        elif isinstance(node.ctx, ast.Load):
            var_name = node.id
            self.rstack.append(self.get_value_of(var_name))

    def visit_Constant(self, node):
        self.rstack.append(Value(node.n))

    def visit_Subscript(self, node):
        result = None
        if isinstance(node.ctx, ast.Load):
            self.visit(node.slice)
            sl  = self.rstack.pop()

            self.visit(node.value)
            val = self.rstack.pop()
            if val is None or sl is None or sl.is_top() or val.is_top():
                self.rstack.append(Value.get_top())
            else:
                varname = '%s[%s]' % (str(val.actual), str(sl.actual))
                if varname in self.valuation:
                    self.rstack.append(self.valuation[varname])
                else:
                    self.rstack.append(Value.get_top())
        elif isinstance(node.ctx, ast.Store):
            assert isinstance(node.value, ast.Name), ('encountered invalid subscript: %s' % node)

            self.visit(node.slice)
            sl  = self.rstack.pop()

            val = node.value.id

            if sl is None or sl.is_top():
                print('write to unknown memory location encountered, nuking value state')
                self.valuation = {}
            else:
                varname = '%s[%s]' % (str(val.actual if isinstance(val, Value) else val), str(sl.actual))
                self.lstack.append(varname)

    def visit_UnaryOp(self, node):
        self.visit(node.operand)
        result = self.rstack.pop()
        if isinstance(node.op, ast.Not):
            self.rstack.append(result.do_not())
        elif isinstance(node.op, ast.USub):
            self.rstack.append(result.do_neg())
        elif isinstance(node.op, ast.UAdd):
            self.rstack.append(result.do_pos)
        elif isinstance(node.op, ast.Invert):
            self.rstack.append(result.do_invert())
        else:
            raise NotImplementedError("Operator %s is not implemented!" % node.op)

    def visit_BoolOp(self, node):
        self.visit(node.values[0])
        left_result = self.rstack.pop()
        self.visit(node.values[1])
        right_result = self.rstack.pop()

        match node.op:
            case ast.And():
                result = left_result.do_and(right_result)
            case ast.Or():
                result = left_result.do_or(right_result)
            case _:
                raise NotImplementedError("Operator %s is not implemented!" % op)
        self.rstack.append(result)


    def visit_Compare(self, node):
        self.visit(node.left)
        left_result = self.rstack.pop()
        comp_results = list()
        for comparator in node.comparators:
            self.visit(comparator)
            comp_results.append(self.rstack.pop())
        # we only support simple compares like 1<2 for now, not something like 1<2<3:
        assert len(comp_results) == 1, comp_results
        assert len(node.ops) == 1, node.ops
        op = node.ops[0]
        result = None
        match op:
            case ast.Eq():
                result = left_result.do_eq(comp_results[0])
            case ast.Gt():
                result = left_result.do_gt(comp_results[0])
            case ast.GtE():
                result = left_result.do_ge(comp_results[0])
            case ast.Lt():
                result = left_result.do_lt(comp_results[0])
            case ast.LtE():
                result = left_result.do_le(comp_results[0])
            case ast.NotEq():
                result = left_result.do_ne(comp_results[0])
            case ast.Eq():
                result = left_result.do_eq(comp_results[0])
            case _:
                raise NotImplementedError("Operator %s is not implemented!" % op)
        self.rstack.append(result)

    def visit_Assign(self, node):
        assert len(node.targets) == 1

        if isinstance(node.value, ast.List) and isinstance(node.targets[0], ast.Name):
            name = node.targets[0].id
            
            for i, expr in enumerate(node.value.elts):
                self.visit(expr)
                val = self.rstack.pop()
                if val is not None and not val.is_top():
                    self.lstack.append('%s[%s]' % (name, i))
                    self.rstack.append(val)
        else:
            self.visit(node.targets[0])
            self.visit(node.value)

    def visit_BinOp(self, node):
        self.visit(node.left)
        left_result = self.rstack.pop()
        self.visit(node.right)
        right_result = self.rstack.pop()

        op = node.op
        result = None
        match op:
            case ast.Add():
                result = left_result.do_add(right_result)
            case ast.Sub():
                result = left_result.do_sub(right_result)
            case ast.Mult():
                result = left_result.do_mul(right_result)
            case ast.Div():
                result = left_result.do_truediv(right_result)
            case ast.FloorDiv():
                result = left_result.do_floordiv(right_result)
            case ast.Mod():
                result = left_result.do_mod(right_result)
            case ast.Pow():
                result = left_result.do_pow(right_result)
            case ast.LShift():
                result = left_result.do_lshift(right_result)
            case ast.RShift():
                result = left_result.do_rshift(right_result)
            case ast.BitOr():
                result = left_result.do_or(right_result)
            case ast.BitXor():
                result = left_result.do_xor(right_result)
            case ast.BitAnd():
                result = left_result.do_and(right_result)
            case ast.MatMult():
                result = left_result.do_matmul(right_result)
            case _:
                raise NotImplementedError("Operator %s is not implemented!" % op)

        self.rstack.append(result)


    def get_value_of(self, varname):
        return (
            Value(self.valuation[varname])
            if varname in self.valuation
            else Value.get_top()
        )

    def update(self, other_valuation):
        for lhs, rhs in zip(self.lstack, self.rstack):
            if rhs.is_top():
                other_valuation.pop(str(lhs), None)
            else:
                other_valuation[str(lhs)] = rhs.actual

class Value:
    __top = None

    @staticmethod
    def get_top():
        """ Static access method. """
        if Value.__top is None:
            Value.__top = Value(top=True)
        return Value.__top

    def is_top(self):
        return self is Value.get_top()

    def __init__(self, actual=None, top=False):
        assert not isinstance(actual, Value)
        if top == True and Value.__top != None:
            """ Virtually private constructor for Top."""
            raise Exception("There may only be one top state!")
        else:
            self.actual = actual

    def do_eq(self, other):
        if self.is_top():
            return self
        if other.is_top():
            return other
        else:
            return Value(self.actual == other.actual)

    def do_ne(self, other):
        if self.is_top():
            return self
        if other.is_top():
            return other
        else:
            return Value(self.actual != other.actual)

    # We need this for negation of Top, since both are True!
    def do_not(self):  
        if self.is_top():
            return self
        else:
            return Value(not self.actual.__bool__())

    # DONE Task 8: greater than
    def do_gt(self,other):
        if self.is_top() or other.is_top():
            return Value.get_top()
        else:
            return Value(self.actual > other.actual)

    def do_lt(self,other):
        if self.is_top() or other.is_top():
            return Value.get_top()
        else:
            return Value(self.actual < other.actual)

    def do_ge(self,other):
        if self.is_top() or other.is_top():
            return Value.get_top()
        else:
            return Value(self.actual >= other.actual)
    def do_le(self,other):
        if self.is_top() or other.is_top():
            return Value.get_top()
        else:
            return Value(self.actual <= other.actual)

    # DONE Task 8: negation
    def do_neg(self):
        if self.is_top():
            return self
        else:
            return Value(-self.actual)

    def do_pos(self):
        if self.is_top():
            return self
        else:
            return Value(+self.actual)

    def do_invert(self):
        if self.is_top():
            return self
        else:
            return Value(~self.actual)


    def do_add(self, other):
        if self.is_top() or other.is_top():
            return Value.get_top()
        else:
            return Value(self.actual + other.actual)

    def do_sub(self, other):
        if self.is_top() or other.is_top():
            return Value.get_top()
        else:
            return Value(self.actual - other.actual)

    def do_mul(self, other):
        # multiplication with zero is special case:
        if self.actual == 0 or other.actual == 0:
            return Value(0)
        elif self.is_top() or other.is_top():
            return Value.get_top()
        else:
            return Value(self.actual * other.actual)

    def do_truediv(self, other):
        if self.is_top() or other.is_top():
            return Value.get_top()
        else:
            return Value(self.actual / other.actual)

    def do_floordiv(self, other):
        if self.is_top() or other.is_top():
            return Value.get_top()
        else:
            return Value(self.actual // other.actual)

    def do_mod(self, other):
        if self.is_top() or other.is_top() or other.actual == 0:
            return Value.get_top()
        else:
            return Value(self.actual % other.actual)

    def do_pow(self, other):
        if other.actual == 0:
            return Value(1)
        if self.actual == 0 and other.actual != 0:
            return Value(0)
        if self.actual == 1 and other.actual != 0:
            return Value(1)
        if self.is_top() or other.is_top():
            return Value.get_top()
        else:
            return Value(self.actual ** other)

    def do_lshift(self, other):
        if self.is_top() or other.is_top() or other.actual < 0:
            return Value.get_top()
        else:
            return Value(self.actual << other.actual)

    def do_rshift(self, other):
        if self.is_top() or other.is_top() or other.actual < 0:
            return Value.get_top()
        else:
            return Value(self.actual >> other.actual)

    def do_or(self, other):
        if other.actual == ~(0):
            return Value(~0)
        if self.is_top() or other.is_top():
            return Value.get_top()
        else:
            return Value(self.actual | other.actual)

    def do_xor(self, other):
        if self.is_top() or other.is_top():
            return Value.get_top()
        else:
            return Value(self.actual ^ other.actual)

    def do_and(self, other):
        if other.actual == 0:
            return Value(0)
        if self.is_top() or other.is_top():
            return Value.get_top()
        else:
            return Value(self.actual & other.actual)

    def do_matmul(self, other):
        pass

# In[25]:


class ValueTransferRelation(TransferRelation):
    def get_abstract_successors(self, predecessor):
        raise NotImplementedError(
            "successors without edge not possible for Value Analysis!"
        )

    def get_abstract_successors_for_edge(self, predecessor, edge):
        v = ValueExpressionVisitor(predecessor.valuation)
        kind = edge.instruction.kind
        if kind == InstructionType.STATEMENT:
            v.visit(edge.instruction.expression)
            successor = ValueState(predecessor)
            v.update(successor.valuation)
            return [successor]
        elif kind == InstructionType.ASSUMPTION:
            v.visit(edge.instruction.expression)
            # lstack should be empty because there is no lhs in an assumption:
            assert len(v.lstack) == 0, v.lstack
            # there should be one value on rstack, namely what the assumption evaluated to:
            assert len(v.rstack) == 1, v.rstack
            result = v.rstack.pop()
            if result.is_top():
                return [copy.copy(predecessor)]
            passed = True if result.actual else False
            return [copy.copy(predecessor)] if passed else []
        elif edge.instruction.kind == InstructionType.CALL:
            newval = ValueState()
            newval.valuation = { edge.instruction.param_names[i] : predecessor.valuation[k] for i,k in enumerate(edge.instruction.arg_names) if k in predecessor.valuation }
            return [newval]
        elif edge.instruction.kind == InstructionType.NONDET:
            successor = ValueState(predecessor)
            if hasattr(edge.instruction, 'target'):
                successor.valuation[edge.instruction.target] = Value.get_top()
            else:
                successor.valuation['__ret'] = Value.get_top()
            return [successor]
        else:
            return [copy.copy(predecessor)]


class ValueAnalysisCPA(CPA):
    def get_initial_state(self):
        return ValueState()

    def get_stop_operator(self):
        return StopSepOperator(ValueState.subsumes)

    def get_merge_operator(self):
        return MergeSepOperator()

    def get_transfer_relation(self):
        return ValueTransferRelation()





================================================
File: pycpa/analyses/__init__.py
================================================

from pycpa.analyses.ARGCPA import ARGCPA, ARGState, GraphableARGState
from pycpa.analyses.LocationCPA import * 
from pycpa.analyses.PropertyCPA import * 
from pycpa.analyses.ValueAnalysisCPA import *

from pycpa.analyses.StackCPA import * 
from pycpa.analyses.CompositeCPA import *

from pycpa.analyses.PredAbsCPA import * 
from pycpa.analyses.PredAbsPrecision import * 




================================================
File: pycpa/ast/ASTPreprocessor.py
================================================
import ast

class ASTPreprocessor(ast.NodeTransformer):
    """
        AST transformer that ensures a few desirable properties of the AST:
        Left sides of assignments are:
            - exactly one target (no compound assignments)
        Right sides of assignments are either: 
            - an arithmetic expression without function calls
            - exactly one function call
        Augmented assignments are expanded to ordinary ones.
        Arguments to function calls are:
            - Names
            - Constants
    """

    def __init__(self):
        self.instruction_stack = list()
        self.current_tmp_ctr = 0

        # stores whether a visited call has to be extracted
        # always the case if not a single expression
        self.extract = False
        self.extract_expr = False

    def push_instruction(self, instruction):
        assert isinstance(instruction, ast.AST)
        self.instruction_stack.append(instruction)

    def push_instruction_below(self, instruction):
        assert isinstance(instruction, ast.AST)
        self.instruction_stack.insert(0, instruction)

    def push_instructions(self, instructions):
        assert isinstance(instructions, list)
        assert all(not isinstance(i, list) for i in instructions)
        self.instruction_stack.extend(instructions)

    def push_instructions_below(self, instructions):
        assert isinstance(instructions, list)
        assert all(not isinstance(i, list) for i in instructions)
        self.instruction_stack.insert(0, instructions)
    
    def pop_instructions(self):
        current = list(reversed(self.instruction_stack))
        self.instruction_stack.clear()
        # self.current_tmp_ctr = 0
        return current

    def visit_sequence(self, statements : list) -> list[ast.AST]:
        result = list()
        for s in statements:
            expr = self.visit(s)
            result.extend(self.pop_instructions())
            result.append(expr)
            self.extract = False
            self.extract_expr = False

        assert all(isinstance(a, ast.AST) for a in result), result
        assert len(self.instruction_stack) == 0
        return result


    def assign_result_to(self, call : ast.AST, return_var : str) -> ast.AST:
        expr = ast.Assign(
            targets = [ast.Name(return_var, ctx=ast.Store())],
            value = call
        )
        ast.copy_location(call, expr)
        ast.fix_missing_locations(expr)
        return expr

    def extract_expression(self, node) -> ast.Name:
        var_name = '__tmp_' + str(self.current_tmp_ctr)
        self.current_tmp_ctr += 1

        self.push_instruction(self.assign_result_to(node, var_name))

        result = ast.Name(
            id = var_name,
            ctx = ast.Load(),
        )
        return result

    def extract_expression_last(self, node) -> ast.Name:
        var_name = '__tmp_' + str(self.current_tmp_ctr)
        self.current_tmp_ctr += 1

        self.push_instruction_below(self.assign_result_to(node, var_name))

        result = ast.Name(
            id = var_name,
            ctx = ast.Load(),
        )
        return result




    def visit_BinOp(self, node):
        if not self.extract_expr:
            return node
        return self.extract_expression(node)
    def visit_Compare(self, node):
        if not self.extract_expr:
            return node
        return self.extract_expression(node)
    def visit_UnaryOp(self, node):
        if not self.extract_expr:
            return node
        return self.extract_expression(node)
    def visit_UnaryOp(self, node):
        if not self.extract_expr:
            return node
        return self.extract_expression(node)

    def visit_Call(self, node: ast.Call) -> ast.Name:
        do_extract = self.extract
        self.extract = True
        self.extract_expr = True

        call = ast.Call(
            func=node.func,
            args=[self.visit(arg) for arg in node.args]
        )
        ast.copy_location(call, node)
        ast.fix_missing_locations(call)

        if do_extract:
            # here, the instruction for this call has to be put under the instructions of the args
            head = self.extract_expression_last(call)
            ast.copy_location(head, node)
            ast.fix_missing_locations(head)

            return head
        else:       
            # call can be kept in place
            return call

    def visit_Assign(self, node) -> ast.Assign:
        self.extract = True
        target, value = node.targets[0], node.value

        if (isinstance(node.targets[0], ast.Tuple) and isinstance(node.value, ast.Tuple)):
            if len(node.targets[0].elts) == len(node.value.elts) > 1:
                target, value = node.targets[0].elts.pop(), node.value.elts.pop()
            
                right = self.visit(value)
                left  = self.visit(target) 
                assign = ast.Assign(
                    targets=[left],
                    value=right
                )
                ast.copy_location(assign, node)
                ast.fix_missing_locations(assign)

                result = self.visit(assign)
                self.push_instruction_below(result)

                return self.visit(node)

            else:
                target, value = node.targets[0].elts[0], node.value.elts[0]

        right = self.visit(value)
        left  = self.visit(target)

        head = ast.Assign([left], right)
        ast.copy_location(head, node)
        ast.fix_missing_locations(head)

        return head

    def visit_If(self, node) -> ast.If:
        body = self.visit_sequence(node.body)
        orelse = self.visit_sequence(node.orelse)

        self.extract = True
        test = self.visit(node.test)

        node.body = body
        node.orelse = orelse
        node.test = test
        return node

    def visit_While(self, node) -> ast.While:
        body = self.visit_sequence(node.body)

        self.extract = True
        test = self.visit(node.test)

        body.extend(self.instruction_stack)   # has to be recomputed for next test
        
        node.body = body
        node.test = test
        return node

    def visit_FunctionDef(self, node) -> ast.Module:
        body = self.visit_sequence(node.body)
        node.body = body
        return node

    def visit_Module(self, node) -> ast.Module:
        body = self.visit_sequence(node.body)
        node.body = body
        return node

              


================================================
File: pycpa/ast/EnsureReturn.py
================================================
import ast
from ast import AST


class EnsureReturn(ast.NodeTransformer):
    """
        AST transformer that ensures that each function ends with a return statement
    """

    def visit_FunctionDef(self, node) -> ast.FunctionDef:
        assert len(node.body) > 0
        match node.body[-1]:
            case ast.Return():
                return node
            case ast.Pass():
                ret = ast.Return()
                ast.copy_location(ret, node)
                node.body[-1] = ret
                return node
            case _:
                ret = ast.Return()
                ast.copy_location(ret, node)
                node.body.append(ret)
                return node
        

              


================================================
File: pycpa/ast/ExpandAugAssign.py
================================================
import ast
import re
import copy

class ExpandAugAssign(ast.NodeTransformer):
    """
        AST transformer that transform augmented assignments into normal ones
    """

    def __init__(self):
        pass

    def visit_AugAssign(self, node) -> ast.AugAssign:
        assign = None
        match node.target:
            case ast.Name() | ast.Subscript():
                lvalue = copy.copy(node.target)
                rvalue = copy.copy(node.target)
                rvalue.ctx = ast.Store()

                assign = ast.Assign(
                    targets =[ lvalue ], 
                    value = ast.BinOp( rvalue,  node.op, node.value )
                )
                ast.copy_location(assign, node)
                ast.fix_missing_locations(assign)
            case _:
                assert False, node.target

        assert isinstance(assign, ast.Assign)
        return assign


================================================
File: pycpa/ast/RemoveBuiltins.py
================================================
import ast
import re

class RemoveBuiltins(ast.NodeTransformer):
    """
        AST transformer that remove function definitions corresponding to builtin functions
    """


    def __init__(self, builtin_identifiers):
        self.builtin = builtin_identifiers
        self.pattern = re.compile(r'^__(tmp|ret)')

    def visit_FunctionDef(self, node) -> ast.FunctionDef:
        """
            remove redefinitions
        """
        if node.name in self.builtin:
            return None
        else:
            return node

    def visit_Name(self, node) -> ast.Name:
        """
            rename variables that use __ prefix (marks verifier-internal identifiers)
        """
        if self.pattern.match(node.id):
            newname = ast.Name(
                id=str('USER') + node.id,
                ctx=node.ctx
            )
            ast.copy_location(newname, node)
            return newname
        else:
            return node
            



              


================================================
File: pycpa/ast/SetExecutionContext.py
================================================
import ast
import re

class SetExecutionContext(ast.NodeTransformer):
    """
        AST transformer that defines relevant python-builtins
    """

    def __init__(self):
        pass

    def visit_Module(self, node) -> ast.Module:
        """ Adds initial statements """
        statement = ast.Assign(
            targets=[ast.Name('__name__', ast.Store())],
            value=ast.Constant('__main__')
        )

        if len(node.body) > 0:
            ast.copy_location(statement, node.body[0])
        else:
            ast.copy_location(statement, node)
        ast.fix_missing_locations(statement)

        node.body.insert(0, statement)
        return node
              







================================================
File: pycpa/ast/__init__.py
================================================

from pycpa.ast.ast import ASTVisualizer

from pycpa.ast.ExpandAugAssign import ExpandAugAssign
from pycpa.ast.ASTPreprocessor import ASTPreprocessor
from pycpa.ast.EnsureReturn import EnsureReturn
from pycpa.ast.RemoveBuiltins import RemoveBuiltins
from pycpa.ast.SetExecutionContext import SetExecutionContext


================================================
File: pycpa/ast/ast.py
================================================
#!/usr/bin/env python

# coding: utf-8

# # Programming Assignment 1: Implementing Configurable Program Analysis
# 
# ## Instructions for Submission and Grading
# 
# - Deadline: **2025-04-08**
# - Total points: 100
#   - There are 10 tasks with 80 points in this Jupyter notebook
#   - We will use 4 hidden programs to test your verifier (20 points, 5 points each)
# - Submission: Upload your finished Jupyter notebook file (i.e., this file) to NTU COOL.
# 
# ## Description
# 
# This programming assignment asks you to implement a minimal software verifier
# based on *Configurable Program Analysis*, the core concept in our course.
# You will practice and apply the concept of CPA by getting your hands dirty.
# 
# The verifier we are going to implement can analyze Python code with basic constructs.
# We leave out the language features unnecessary for grasping the concepts by limiting our verifier to:
# 
# * only integers and Booleans like `True` and `False`
# * only the following operators in expressions: `+ - * / == !=`
# * only `while` loops, `break`, and `continue`, but no for-each loops
# * only assignments of the simple form `a = b + c` (no augmented assignments like ` a += b` or multiple assignments like `(a,b,c) = (1,2,3)`)
# * not consider function declarations. Functions are only used to
#     1. mark target states (by calling `reach_error()`)  
#     2. generate nondeterministic values (by calling `nondet()`)  
#     (These functions can be assumed already-declared, i.e., no need to be declared.)
# 
# Please follow the explanations below to implement the verifier step by step by filling in the TODOs.
# You can test your implementation with the provided programs.

# ## 1. Parsing an input program and generating a CFA (3 tasks, 20 points)
# 
# In this part, we will look at how we can get a CFA from an abstract syntax tree (AST),
# which we will use the Python package `ast` to produce from a given Python program.
# 
# ### 1.1 Visualizing the AST
# 
# A frequently used design pattern to extract information from an AST is the [*visitor pattern*](https://refactoring.guru/design-patterns/visitor).
# In this exercise, we will use it to visualize the AST.
# In later tasks, we will use it for all kinds of other things, like generating the CFA, evaluating expressions, etc.
# We will use the following example program that contains most of the considered syntactical features:

# In order to parse this program into an AST, we use the package `ast` :

# In[2]:


import ast
import astpretty


# This textual representation shows how the AST decomposes the source code into syntactical building blocks.
# More details can be found at https://docs.python.org/3/library/ast.html.
# Basically, every element from the grammar has a corresponding class used in the AST, which is also used for the visitor pattern.
# 
# There is a predefined class `ast.NodeVisitor` from which we can inherit.
# This class contains a method `generic_visit(self, node)` that is called for every node while traversing the AST.
# Below is a simple example of a class `ASTPrinter(ast.NodeVisitor)` that visits each node and
# prints the node's class as well as a number identifying in which order the nodes are explored.
# 
# Furthermore, `ast.NodeVisitor` contains a method `visit_<classname>(self,node)` for every class name that can appear in the AST.
# The default implementation of `generic_visit(self, node)` makes sure that
# this method is called once a corresponding node is encountered in the AST during traversal.
# In the example below, we overwrote one of those methods to show you how this feature can be used.
# Please notice that we still need to call `generic_visit`,
# otherwise the traversal of the AST will stop and child nodes will not be visited.

# In[3]:

import sys

class ASTPrinter(ast.NodeVisitor):
    def __init__(self, file=sys.stdout):
        self.file = file
        self.node_counter = 0

    def generic_visit(self, node):
        node_name = "%d %s" % (self.node_counter, node.__class__.__name__)
        self.node_counter += 1
        self.file.write(node_name + '\n')
        return ast.NodeVisitor.generic_visit(self, node)
    def visit_Assign(self, node):
        self.file.write("Found an assign node:\n")
        self.generic_visit(node)



# #### Task 1: Visitor that counts `Name` nodes (3 points)
# 
# Write a visitor that counts the number of `Name` nodes in an AST:

# In[4]:


class ASTNameCounter(ast.NodeVisitor):
    def __init__(self):
        self.count = 0
    
    def visit_Name(self, node):
        self.count += 1
        return ast.NodeVisitor.generic_visit(self, node)

from graphviz import Digraph

class ASTVisualizer(ast.NodeVisitor):
    def __init__(self):
        self.node_stack = list()
        self.graph = Digraph()
        self.node_counter = 0

    def generic_visit(self, node):
        # using this name in the displayed AST
        node_name = "%d %s" % (self.node_counter, node.__class__.__name__)
        self.node_counter += 1
        self.graph.node(node_name)

        # get parent node's name from stack and create an edge
        if len(self.node_stack) > 0:
            self.graph.edge(self.node_stack[-1], node_name)
            self.node_stack.pop()

        # for each child, push this node's name on the stack
        for c in ast.iter_child_nodes(node):
            self.node_stack.append(node_name)

        return ast.NodeVisitor.generic_visit(self, node)



================================================
File: pycpa/config/PredicateAnalysis.py
================================================
from pycpa.analyses import PredAbsPrecision, PredAbsCPA
from pycpa.analyses import CompositeCPA
from pycpa.analyses import LocationCPA
from pycpa.analyses import StackCPA
from pycpa.analyses import ARGCPA
from pycpa.analyses import ValueAnalysisCPA

def get_cpas(entry_point=None, cfa_roots=None, output_dir=None, **params):
    assert entry_point

    if cfa_roots is None:
        cfa_roots = [entry_point]
    precision = PredAbsPrecision.from_cfa(cfa_roots)

    # dump initial precision
    if output_dir:
        with open(output_dir + 'precision_initial.txt', 'w') as f:
            f.write(str(precision))

    return [StackCPA(CompositeCPA([LocationCPA(entry_point), PredAbsCPA(precision)]))]




================================================
File: pycpa/config/ReachabilityAnalysis.py
================================================
from pycpa.analyses import CompositeCPA
from pycpa.analyses import LocationCPA
from pycpa.analyses import StackCPA
from pycpa.analyses import ARGCPA
from pycpa.analyses import ValueAnalysisCPA

def get_cpas(entry_point=None, **params):
    assert entry_point
    return [StackCPA(LocationCPA(entry_point))]



================================================
File: pycpa/config/ValueAnalysis.py
================================================
from pycpa.analyses import CompositeCPA
from pycpa.analyses import LocationCPA
from pycpa.analyses import StackCPA
from pycpa.analyses import ARGCPA
from pycpa.analyses import ValueAnalysisCPA

def get_cpas(entry_point=None, **params):
    assert entry_point
    return [StackCPA(CompositeCPA([LocationCPA(entry_point), ValueAnalysisCPA()]))]



================================================
File: pycpa/config/ValueAnalysisMergeJoin.py
================================================
from pycpa.cpa import MergeJoinOperator
from pycpa.analyses import CompositeCPA
from pycpa.analyses import LocationCPA
from pycpa.analyses import StackCPA
from pycpa.analyses import ARGCPA
from pycpa.analyses import ValueAnalysisCPA


def get_cpas(entry_point=None, **params):
    assert entry_point
    ValueAnalysisCPA.get_merge_operator = lambda x: MergeJoinOperator()
    return [StackCPA(CompositeCPA([LocationCPA(entry_point), ValueAnalysisCPA()]))]




================================================
File: pycpa/property/ReachSafety.py
================================================

from pycpa.cpa import WrappedAbstractState
from pycpa.analyses import PropertyCPA, PropertyState, CompositeState

from pycpa.specification import Specification, ARGVisitor
from pycpa.verdict import Verdict

class ReachSafetyARGVisitor(ARGVisitor):
    def __init__(self):
        self.result = Verdict.TRUE

    def visit_PropertyState(self, state : PropertyState):
        sr = Verdict.TRUE if state.safe else Verdict.FALSE
        self.result &= sr
        
    def verdict(self) -> Verdict:
        return self.result

def get_cpas(**params):
    return [PropertyCPA()]

def check_arg_state(state):
    v = ReachSafetyARGVisitor()
    v.visit(state)
    return v.verdict()

    




================================================
File: pycpa/refinement/cegar_helper.py
================================================
#!/usr/bin/env python
"""CEGAR helper utilities

Two high-level helpers used by the refinement loop
-------------------------------------------------
* is_path_feasible(path_edges)             → bool
* refine_precision(path_edges, old_prec)   → set(FNode)

They build formulas **in SSA form** so variables from different edges
cannot clash, and they use pysmt for SAT + interpolation.
"""

from __future__ import annotations
from typing import List, Set, Dict

from pysmt.shortcuts import And, is_sat, TRUE
from pysmt.solvers.interpolation import Interpolator
from pysmt.fnode import FNode

# — robust imports whether code lives in a flat folder or a package —
try:
    from pycpa.cfa import InstructionType, CFAEdge          # type: ignore
except ImportError:
    from cfa import InstructionType, CFAEdge                # type: ignore

try:
    from pycpa.analyses.PredAbsPrecision import PredAbsPrecision
except ImportError:
    from PredAbsPrecision import PredAbsPrecision


# --------------------------------------------------------------------------- #
# Internal: translate one CFA edge into an SSA formula
# --------------------------------------------------------------------------- #
def _edge_formula_ssa(edge: CFAEdge, ssa_idx: Dict[str, int]) -> FNode:
    """Return a Boolean pysmt formula for *edge* and update `ssa_idx`."""
    match edge.instruction.kind:
        case InstructionType.STATEMENT:
            return PredAbsPrecision.ssa_from_assign(edge, ssa_idx)
        case InstructionType.ASSUMPTION:
            return PredAbsPrecision.ssa_from_assume(edge, ssa_idx)
        case _:
            # calls, nondet, etc. – sound over-approximation
            return TRUE()


# --------------------------------------------------------------------------- #
# 1.  Feasibility check
# --------------------------------------------------------------------------- #
def is_path_feasible(path_edges: List[CFAEdge]) -> bool:
    """Concrete feasibility check for an abstract counter-example path."""
    ssa_idx: Dict[str, int] = {}
    phi = TRUE()
    for e in path_edges:
        phi = And(phi, _edge_formula_ssa(e, ssa_idx))
    return is_sat(phi)


# --------------------------------------------------------------------------- #
# 2.  Precision refinement via interpolation
# --------------------------------------------------------------------------- #
def refine_precision(path_edges: List[CFAEdge],
                     old_precision: Set[FNode]) -> Set[FNode]:
    """
    Given a *spurious* path, return an enlarged predicate set.
    """
    if not path_edges:
        return set(old_precision)

    # Build per-edge SSA formulas  A₁,…,Aₙ
    formulas: List[FNode] = []
    ssa_idx: Dict[str, int] = {}
    for e in path_edges:
        formulas.append(_edge_formula_ssa(e, ssa_idx))

    # Need ≥2 blocks for sequence interpolation
    if len(formulas) == 1:
        formulas.append(TRUE())

    interp = Interpolator()
    try:
        itps = interp.sequence_interpolant(formulas)
    except Exception as exc:
        # Solver without interpolation support; keep old precision.
        print("[WARN] interpolation failed:", exc)
        return set(old_precision)

    new_preds: Set[FNode] = set(old_precision)
    for I in itps:
        for atom in I.get_atoms():
            if atom.get_type().is_bool_type():
                new_preds.add(atom)

    return new_preds




================================================
File: pycpa/utils/visual.py
================================================
#!/usr/bin/env python3
"""
pycpa.utils.visual
------------------

Reusable helpers for drawing ASTs, CFAs, ARGs … with Graphviz.

• Graphable           – minimal interface a node must implement
• graphable_to_dot()  – generic breadth-first walk → graphviz.Digraph
• ASTVisualizer       – ast.NodeVisitor ⇒ Graphviz graph of the AST
"""

from __future__ import annotations
import ast
from typing import Iterable
from graphviz import Digraph


# ------------------------------------------------------------------ #
#  very small “interface”                                            #
# ------------------------------------------------------------------ #
class Graphable:
    def get_node_label(self) -> str: ...
    def get_successors (self) -> Iterable["Graphable"]: ...
    def get_edge_labels(self, succ: "Graphable") -> Iterable[str]: ...


# ------------------------------------------------------------------ #
#  generic Graphable → graphviz helper                               #
# ------------------------------------------------------------------ #
def graphable_to_dot(roots: Iterable[Graphable],
                     *,
                     name: str = "G") -> Digraph:
    g = Digraph(name=name, graph_attr={"rankdir": "LR"})
    seen: set[Graphable] = set()

    def visit(n: Graphable):
        if n in seen:
            return
        seen.add(n)
        g.node(str(id(n)), label=n.get_node_label(), shape="box")
        for succ in n.get_successors():
            visit(succ)
            for lbl in n.get_edge_labels(succ):
                g.edge(str(id(n)), str(id(succ)), label=lbl)

    for r in roots:
        visit(r)
    return g


# ------------------------------------------------------------------ #
#  AST → Graphviz                                                    #
# ------------------------------------------------------------------ #
class ASTVisualizer(ast.NodeVisitor):
    """
    Usage:
        v = ASTVisualizer()
        v.visit(ast_tree)
        v.graph.render("out/ast")
    """
    def __init__(self):
        self.graph = Digraph("AST", node_attr={"shape": "box"})
        self._idx  = 0
        self._stack: list[str] = []

    # helpers --------------------------------------------------------
    def _new_id(self) -> str:
        self._idx += 1
        return f"n{self._idx}"

    def _add_node(self, label: str) -> str:
        nid = self._new_id()
        self.graph.node(nid, label=label)
        if self._stack:
            self.graph.edge(self._stack[-1], nid)
        return nid

    # generic visitors ----------------------------------------------
    def generic_visit(self, node):
        label = type(node).__name__
        if isinstance(node, ast.Constant):
            label += f"\\n{repr(node.value)}"
        elif isinstance(node, ast.Name):
            label += f"\\n{node.id}"
        cur = self._add_node(label)
        self._stack.append(cur)
        super().generic_visit(node)
        self._stack.pop()





================================================
File: test_progs/cegar_example.py
================================================
# example_cegar.py

# Model a nondet choice; we don't actually execute it, just for CFA building
def nondet():
    pass

# Error‐reporting hook for the verifier CPA
def reach_error():
    pass

def VERIFIER_assert(cond):
    if not cond:
        reach_error()
    return

def main():
    # l0
    x = nondet()
    # branch [x < 10]
    if x < 10:
        # l2→l3
        x = x + 1
    # at l3: check that we never reach x == 20
    VERIFIER_assert(x != 20)

if __name__ == "__main__":
    main()




================================================
File: test_progs/collatz.py
================================================
def abort():
    pass
def reach_error():
    pass

def a():
    y = 2
    return y


def b():
    a()

def VERIFIER_assert(cond):
    if not cond:
        reach_error()
    else:
        pass
    return 


def main():
    x = 10
    y = 1
    z = 5
    while z > 1:
        y = x + y
        a()
        x += __ret
        if z % 2 == 0:
            z = z // 2
        else:
            z = 3 * z + 1
    VERIFIER_assert((x%2 == 0))

    b()

    c()



================================================
File: test_progs/collatz_safe.py
================================================
n = 17             # any positive start < 1000
step = 0
while n != 1 and step < 200:   # hard bound keeps loop finite
    if n % 2 == 0:
        n = n // 2
    else:
        n = 3*n + 1
    step = step + 1

assert n == 1                  # always true under the bound




================================================
File: test_progs/divide_path_bug.py
================================================
from random import randint      # nondet int

y = randint(-1, 1)              # {-1,0,1}
if y == 0:                      # feasible path
    reach_error()

x = 10 // y                     # otherwise safe (±1)
assert x in (-10, 10)




================================================
File: test_progs/even_odd_accumulate_safe.py
================================================
def inc(x):
    return x + 1

def accumulate(n, m):
    i = 0
    total = 0
    while i < n:
        j = 0
        while j < m:
            if (i + j) % 2 == 0:
                total += i * j
            else:
                total += i + j
            j = inc(j)
        i = inc(i)
    return total

result = accumulate(3, 4)
# Hand-computed: 24
if result != 24:
    raise Exception(f"Wrong: got {result}, expected 24")




================================================
File: test_progs/even_odd_accumulate_unsafe.py
================================================
def inc(x):
    return x + 1

def accumulate_buggy(n, m):
    i = 0
    total = 0
    while i < n:
        j = 0
        while j < m:
            # BUG: both branches use i*j
            if (i + j) % 2 == 0:
                total += i * j
            else:
                total += i * j
            j = inc(j)
        i = inc(i)
    return total

result = accumulate_buggy(3, 4)
# Wrong actual: 18, but we assert 24
if result != 24:
    raise Exception(f"Wrong: got {result}, expected 24")




================================================
File: test_progs/flag_loop_safe.py
================================================
flag = 0
outer = 0
while outer < 15:
    inner = 0
    while inner < 20:
        if flag == 1:
            break              # will never execute
        inner = inner + 1
    outer = outer + 1

assert flag == 0               # invariant holds




================================================
File: test_progs/nested_cegar_safe.py
================================================
def inc(x):
    return x + 1

def double_inc(x):
    return x + 2

def accumulate_safe(n):
    i = 0
    total = 0
    while i < n:
        j = 0
        inner = 0
        while j < 3:
            inner += double_inc(j)
            j = inc(j)
        total += inner
        i = inc(i)
    return total

# Trigger loop nesting and arithmetic logic
result = accumulate_safe(4)  # 4 * (2+4+6) = 4 * 12 = 48
assert result == 48




================================================
File: test_progs/nested_cegar_safe_explicit.py
================================================
def inc(x):
    return x + 1

def double_inc(x):
    return x + 2

def accumulate_safe(n):
    i = 0
    total = 0
    while i < n:
        j = 0
        inner = 0
        while j < 3:
            inner += double_inc(j)
            j = inc(j)
        total += inner
        i = inc(i)
    return total

result = accumulate_safe(4)  # Should be 4 * (2 + 4 + 6) = 48
if result != 48:
    raise Exception(f"Assertion failed: result was {result}, expected 48")




================================================
File: test_progs/nested_cegar_unsafe.py
================================================
def inc(x):
    return x + 1

def buggy_double_inc(x):
    return x + 3  # Bug: +3 instead of +2

def accumulate_unsafe(n):
    i = 0
    total = 0
    while i < n:
        j = 0
        inner = 0
        while j < 3:
            inner += buggy_double_inc(j)
            j = inc(j)
        total += inner
        i = inc(i)
    return total

# Should be 4 * (2+4+6) = 48
# But becomes 4 * (3+5+7) = 60 → assertion should FAIL
result = accumulate_unsafe(4)
assert result == 48




================================================
File: test_progs/nested_funcs_safe.py
================================================
def incr(x):          # first user function
    return x + 1

def sum_to(n):        # second function: Σ_{i=0}^{n-1} i
    s = 0
    i = 0
    while i < n:
        s = s + i
        i = incr(i)
    return s

total = sum_to(5)     # 0+1+2+3+4 = 10
assert total == 10




================================================
File: test_progs/off_by_one_bug.py
================================================
size = 10
idx  = 0
while idx <= size:     # off-by-one: should be <
    if idx == size:
        reach_error()  # idx reaches 10 → bug
    idx = idx + 1




================================================
File: test_progs/sum_cubes_safe.py
================================================
def inc(x):
    return x + 1

def add(x, y):
    return x + y

def sum_cubes(n):
    s = 0
    i = 0
    while i < n:
        j = 0
        while j < n:
            k = 0
            while k < n:
                s += add(i, add(j, k))
                k = inc(k)
            j = inc(j)
        i = inc(i)
    return s

result = sum_cubes(3)
# Sum over 0≤i,j,k<3 of (i+j+k) = 81
if result != 81:
    raise Exception(f"Wrong: got {result}, expected 81")




================================================
File: test_progs/sum_cubes_unsafe.py
================================================
def inc(x):
    return x + 1

def add(x, y):
    return x + y + 1  # BUG: extra +1

def sum_cubes(n):
    s = 0
    i = 0
    while i < n:
        j = 0
        while j < n:
            k = 0
            while k < n:
                s += add(i, add(j, k))
                k = inc(k)
            j = inc(j)
        i = inc(i)
    return s

result = sum_cubes(3)
# Actual is 108, but we assert 81
if result != 81:
    raise Exception(f"Wrong: got {result}, expected 81")




================================================
File: test_progs/sum_mult_safe.py
================================================
def mult(x, y):
    return x * y

def sum_mult(n):
    total = 0
    for i in range(1, n+1):
        for j in range(1, i+1):
            total += mult(i, j)
    return total

result = sum_mult(4)
# 1 + (2+4) + (3+6+9) + (4+8+12+16) = 65
if result != 65:
    raise Exception(f"Wrong: got {result}, expected 65")




================================================
File: test_progs/sum_mult_unsafe.py
================================================
def mult(x, y):
    return x * (y + 1)  # BUG: uses y+1

def sum_mult(n):
    total = 0
    for i in range(1, n+1):
        for j in range(1, i+1):
            total += mult(i, j)
    return total

result = sum_mult(4)
# Actual is 95, but we assert 65
if result != 65:
    raise Exception(f"Wrong: got {result}, expected 65")




================================================
File: test_progs/test1.py
================================================
# safe_linear.py
x = 3
y = 5
z = x + y          # 8
assert z == 8




================================================
File: test_progs/test2.py
================================================
# safe_counter.py
i = 0
limit = 7
while i < limit:   # executes exactly 7 times
    i = i + 1

assert i == 7




================================================
File: test_progs/test3.py
================================================
# unsafe_modulo.py
     # our analyser treats this as an error edge

x = 17
if (x % 2) == 1:          # 17 is odd → true-branch taken
    reach_error()

# else‐branch unreachable but included so the CFA has an assumption edge




================================================
File: test_progs/test4.py
================================================
# unsafe_modulo.py
       # our analyser treats this as an error edge

x = 17
if (x % 2) == 1:          # 17 is odd → true-branch taken
    reach_error()

# else‐branch unreachable but included so the CFA has an assumption edge




================================================
File: test_progs/test5.py
================================================
# unsafe_nested.py
from random import randint

x = 0
for outer in range(3):           # fixed 3 iterations
    y = randint(0, 10)           # treated as nondet
    while y > 0:
        y = y - 1
        x = x + 1

assert x < 0        # always false → bug reachable




================================================
File: test_progs/test6.py
================================================
# func_loop_bug.py
def dec(x):
    return x - 1

n = 3
while n >= 0:
    if n == 0:
        reach_error()  # reachable on last iteration
    n = dec(n)



