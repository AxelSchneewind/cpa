#!env python


# file cpp2py.py
# adapted from https://pypi.org/project/cpp2py/
from pycparser import c_parser
from pycparser import c_ast
import pycparser

import io
import re
import ast

tab = '\t'
def write_one_line(buf, depth):
    return f'{tab:.{depth}}{buf}\n'


# TODO: support literals with f

# how to map c types to python types
type_map = {
    'bool'     : 'bool',
    'int'      : 'int',
    'char'     : 'int',
    'float'    : 'float',
    'double'   : 'float'
}

class Ast2Py:
    def __init__(self, ignore_symbols : set[str]):
        self.import_file_list  = []
        self.ignore_symbols = ignore_symbols


    def import_list(self):
        ret = ''
        self.import_file_list = list(set(self.import_file_list))
        for i in self.import_file_list:
            ret += f'from {i} import *\n'
        return ret

    def ast2py(self, ast,start_line=0):
        ret = ''
        for i in ast.ext:
            ret += self.ast2py_one_node(i)
        return ret

    def ast2py(self, ast, filelike):
        self.stack = list()
        depth = 0

        # uppermost level of ast
        for i in reversed(ast.ext):
            self.push_expr(i)
            self.push_newline(depth)

        while len(self.stack) > 0:
            element = self.stack.pop()
            match element:
                case str():
                    filelike.write(element)
                case int():
                    filelike.write('\n' + '\t'*element)
                    depth = element
                case _:
                    self.ast2py_one_node(element, depth)
        return

    def push_newline(self, depth):
        assert isinstance(depth, int)
        self.stack.append(depth)

    def push_expr(self, expr):
        assert not isinstance(expr, int)
        self.stack.append(expr)

    def ast2py_one_node(self, n, depth):
        match n:
            case c_ast.Pragma():
                # include as comment
                # self.push_expr('# %s' % str(n))
                # self.push_newline(depth)
                return

            case c_ast.FuncDecl():
                # include as comment
                # self.push_expr('# %s' % str(n))
                # self.push_newline(depth)
                return
            case c_ast.FuncDef():
                if n.decl.name in self.ignore_symbols:
                    return

                self.push_newline(depth)
                self.push_expr(n.body)
                self.push_newline(depth + 1)
                self.push_expr('):')

                if n.decl.type.args:
                    for i in reversed(n.decl.type.args.params[1:]):
                        if isinstance(i, c_ast.Decl):
                            if i.init:
                                self.push_expr(i.init)
                                self.push_expr('=')
                            if i.type and i.type.type and isinstance(i.type.type, (c_ast.Typename)):
                                self.push_expr(i.type.type)
                                self.push_expr(':')
                            self.push_expr(i.name)
                            self.push_expr(',')

                    i = n.decl.type.args.params[0]
                    if isinstance(i, c_ast.Decl):
                        if i.init:
                            self.push_expr(i.init)
                            self.push_expr('=')
                        if i.type and i.type.type and isinstance(i.type.type, (c_ast.Typename)):
                            self.push_expr(i.type.type)
                            self.push_expr(':')
                        self.push_expr(i.name)

                self.push_expr('def %s (' % n.decl.name)

            case c_ast.Typedef():
                if n.name in self.ignore_symbols:
                    return

                self.push_expr(n.type)
                self.push_expr(' = ')
                self.push_expr(n.name)

            # TODO: initlist

            case c_ast.Compound():
                if n.block_items and len(n.block_items) > 0:
                    for i in reversed(n.block_items[1:]):
                        self.push_expr(i)
                        self.push_newline(depth)
                    self.push_expr(n.block_items[0])
                else:
                    self.push_newline(depth)
                    self.push_expr('pass')

            case c_ast.EmptyStatement():
                self.push_newline(depth)
                self.push_expr('pass')

            case c_ast.Return():
                self.push_newline(depth)
                if n.expr:
                    self.push_expr(n.expr)
                self.push_expr('return ')

            case c_ast.Constant():
                py_constant = '0'

                pref = re.match(r'^[^1-9]*', py_constant)
                match n.type:
                    case 'double' | 'float':
                        num = re.sub(r'[UuLlFf]*$', '', n.value)
                        py_constnat = num
                    case 'int' | 'long':
                        num = re.sub(r'[UuLlFf]*$', '', n.value)
                        is_hex = re.sub(r'^0+x$', '0x', num)
                        if is_hex:
                            num = re.sub(r'^0+x$', '0x', num)
                        else:
                            num = re.sub(r'^0+$', '0o', num)
                        py_constant = num
                    case 'string':
                        py_constant = str(n.value)
                    case _:
                        print('unknown constant type: ', str(n), file=sys.stderr)
                self.push_expr(py_constant)

            case c_ast.ID():
                self.push_expr(n.name)

            case c_ast.Typename():
                selected = 'int'
                if n in type_map:
                    selected = str(type_map[n])
                self.push_expr(selected)

            case c_ast.Struct():
                self.push_expr(n.name)

            case c_ast.TypeDecl():
                self.push_expr(n.type)

            case c_ast.IdentifierType():
                selected = 'int'
                for n in n.names:
                    if n in type_map:
                        selected = str(type_map[n])
                self.push_expr(selected)

            case c_ast.PtrDecl():
                self.push_expr('int')

            case c_ast.Decl(name=name):
                if name in self.ignore_symbols:
                    return

                if n.init is not None:
                    self.push_expr(n.init)
                    self.push_expr(' = ')
                    self.push_expr(n.type.type)
                    self.push_expr(' : ')
                    self.push_expr(name)
                else:
                    #add char* support
                    if isinstance(n.type, c_ast.PtrDecl) and isinstance(n.type.type, c_ast.TypeDecl) and isinstance(n.type.type.type, c_ast.IdentifierType):
                        # if n.type.type.type.names ==['char']:
                        #     ostr =  f'{n.type.declname} = CharPtr()'
                        #     self.import_file_list.append('cpp2py.cpp2py_ctype')
                        #     self.push_expr(ostr)
                        # ignoring pointers
                        print('Ignoring pointer declaration', file=sys.stderr)
                        return
                    elif isinstance(n.type, c_ast.ArrayDecl) \
                        and isinstance(n.type.type, c_ast.TypeDecl) and \
                        isinstance(n.type.type.type, (c_ast.IdentifierType, c_ast.Typename)):
                            identifier = n.type.type.declname
                            typ = n.type.type.type
                            dim = n.type.dim
                            self.push_expr(') ]')
                            self.push_expr(dim)
                            self.push_expr('() for i in range(')
                            self.push_expr(typ)
                            self.push_expr(' = [ ')
                            self.push_expr(identifier)
                    elif isinstance(n.type, c_ast.Struct):
                        name = n.type.name

                        self.push_newline(depth)

                        # constructor
                        if n.type.decls:
                            for i in reversed(n.type.decls):
                                self.push_newline(depth + 2)
                                self.push_expr(i.name)
                                self.push_expr(' = ')
                                self.push_expr(i.name)
                                self.push_expr('self.')
                            self.push_newline(depth + 2)

                            self.push_expr('):')
                            for i in reversed(n.type.decls):
                                if isinstance(i, c_ast.Decl):
                                    if i.init:
                                        self.push_expr(i.init)
                                        self.push_expr(' = ')
                                    else:
                                        self.push_expr(' = None')
                                    if i.type.type and isinstance(i.type.type, (c_ast.Typename)):
                                        self.push_expr(i.type.type)
                                        self.push_expr(':')
                                    self.push_expr(i.name)
                                    self.push_expr(', ')
                        else:
                            self.push_expr('pass')
                            self.push_newline(depth + 2)
                            self.push_expr('):')

                        self.push_expr('def __init__(self')
                        self.push_newline(depth + 1)
                        self.push_expr(': ')
                        self.push_expr(name)
                        self.push_expr('class ')
                        self.push_newline(depth)
                    elif isinstance(n.type, c_ast.FuncDecl):
                        # ignore function declarations
                        pass
                    elif isinstance(n.type, c_ast.Union):
                        self.push_newline(depth)

                        # add keyword-based constructor
                        self.push_expr('setattr(self, k, kwargs[k])')
                        self.push_newline(depth + 3)
                        self.push_expr('for k in kwargs:')
                        self.push_newline(depth + 2)
                        self.push_expr('def __init__(self, **kwargs):')
                        self.push_newline(depth + 1)
                        self.push_expr(': ')
                        self.push_expr(name)
                        self.push_expr('class ')
                        self.push_newline(depth)

                        # declare all types
                        if n.type.decls:
                            for i in reversed(n.type.decls):
                                if isinstance(i, c_ast.Decl):
                                    self.push_expr(i)
                            self.push_newline(depth)

                    elif isinstance(n.type, c_ast.Enum):
                        self.push_newline(depth)

                        # constructor
                        if n.type.values:
                            for i in reversed(n.type.values.enumerators):
                                self.push_newline(depth + 1)
                                self.push_expr(i.value)
                                self.push_expr(' = ')
                                self.push_expr(i.name)
                            self.push_newline(depth + 1)
                        else:
                            self.push_expr('pass')
                            self.push_newline(depth + 1)

                        self.push_expr(': ')
                        self.push_expr(name)
                        self.push_expr('class ')
                        self.push_newline(depth)
                    elif isinstance(n.type, c_ast.TypeDecl):
                        self.push_expr(n.type.type)
                    else:
                        print('unsupported declaration type: ', str(n), file=sys.stderr)

            case c_ast.Assignment():
                if not isinstance(n.lvalue, c_ast.ID):
                    print('assigment to non-ID lvalue', n.lvalue, file=sys.stderr)
                    return

                self.push_expr(n.rvalue)
                self.push_expr(' ')
                self.push_expr(n.op)
                self.push_expr(' ')
                self.push_expr(n.lvalue)


            case c_ast.StructRef():
                self.push_expr(n.field)
                self.push_expr('.')
                self.push_expr(n.name)

            case c_ast.ArrayRef():
                self.push_expr(']')
                self.push_expr(n.subscript)
                self.push_expr('[')
                self.push_expr(n.name)

            case c_ast.Break():
                self.push_newline(depth)
                self.push_expr('break')

            case c_ast.Continue():
                self.push_newline(depth)
                self.push_expr('continue')

            case c_ast.DoWhile():
                self.push_newline(depth)

                self.push_expr('break')
                self.push_newline(depth + 2)
                self.push_expr(':')
                if n.cond:
                    self.push_expr(n.cond)
                else:
                    self.push_expr('False')
                self.push_expr('if not ')
                self.push_newline(depth + 1)

                self.push_expr(n.stmt)
                self.push_newline(depth + 1)
                self.push_expr('while True:')

            case c_ast.While():
                self.push_newline(depth)
                self.push_expr(n.stmt)
                self.push_newline(depth + 1)
                self.push_expr(':')
                if n.cond:
                    self.push_expr(n.cond)
                else:
                    self.push_expr('True')
                self.push_expr('while ')


            case c_ast.For():
                self.push_newline(depth)

                if n.next is None and n.stmt is None:
                    self.push_expr('pass')
                    self.push_newline(depth + 1)

                if n.next:
                    self.push_expr(n.next)
                    self.push_newline(depth + 1)

                if n.stmt:
                    self.push_expr(n.stmt)
                    self.push_newline(depth + 1)

                self.push_expr(':')
                if n.cond:
                    self.push_expr(n.cond)
                else:
                    self.push_expr('True')
                self.push_expr('while ')

                if n.init:
                    print(n.init)
                    self.push_newline(depth)
                    self.push_expr(n.init)

                self.push_newline(depth)
                
            case c_ast.If():
                if n.iffalse:
                    self.push_newline(depth)

                    self.push_expr(n.iffalse)
                    self.push_newline(depth + 1)

                    self.push_expr('else:')

                self.push_newline(depth)
                self.push_expr(n.iftrue)
                self.push_newline(depth + 1)

                self.push_expr(':')
                self.push_expr(n.cond)
                self.push_expr('if ')

            case c_ast.Switch():
                self.push_newline(depth)
                self.push_expr(n.stmt)
                self.push_newline(depth + 1)

                self.push_expr(':')
                self.push_expr(n.cond)
                self.push_expr('match ')

            case c_ast.Case():
                if all(not isinstance(s, c_ast.Break) for s in n.stmts):
                    print('Warning: case does not contain a break statement! (code nonequivalent)', file=sys.stderr)

                for s in reversed(n.stmts):
                    self.push_expr(s)
                    self.push_newline(depth + 1)

                self.push_expr(':')
                self.push_expr(n.expr)
                self.push_expr('case ')

            case c_ast.Default():
                if all(not isinstance(s, c_ast.Break) for s in n.stmts):
                    print('Warning: case does not contain break statement!', file=sys.stderr)

                for s in reversed(n.stmts):
                    self.push_expr(s)
                    self.push_newline(depth + 1)

                self.push_expr('case _:')


            # goto unsupported
            case c_ast.Goto():
                print('encountered goto, ignoring', file=sys.stderr)
                self.push_expr('# goto ' + n.name)
                self.push_expr('pass')

            case c_ast.Label():
                self.push_expr(n.stmt)
                self.push_newline(depth)
                # label name becomes comment
                self.push_expr('# ' + n.name)


            case c_ast.BinaryOp():
                py_op = str(n.op)

                match py_op:
                    case '&&':
                        py_op = ' and '
                    case '||':
                        py_op = ' or '
                    case _:
                        py_op = py_op
                if isinstance(n.right, c_ast.BinaryOp):
                    self.push_expr(')')
                    self.push_expr(n.right)
                    self.push_expr('(')
                else:
                    self.push_expr(n.right)

                self.push_expr(py_op)

                if isinstance(n.left, c_ast.BinaryOp):
                    self.push_expr(')')
                    self.push_expr(n.left)
                    self.push_expr('(')
                else:
                    self.push_expr(n.left)

            case c_ast.UnaryOp():
                match n.op:
                    case '!':
                        self.push_expr(n.expr)
                        self.push_expr('not ')
                    case '++' | 'p++':
                        self.push_expr(' += 1 ')
                        self.push_expr(n.expr)
                    case '--' | 'p--':
                        self.push_expr(' -= 1 ')
                        self.push_expr(n.expr)
                    case  '-' | '+' | '~':
                        self.push_expr(n.expr)
                        self.push_expr(str(n.op))
                    # simulate dereference by id()
                    case  '&':
                        self.push_expr(')')
                        self.push_expr(n.expr)
                        self.push_expr('id(')
                    # simulate sizeof by .__get_sizeof__()
                    # maybe use sys.getsizeof() instead?
                    case 'sizeof':
                        self.push_expr('.__sizeof__()')
                        self.push_expr(n.expr)
                    case '*':
                        print("Can't handle pointer dereference", n, file=sys.stderr)
                    case _:
                        print("Unknown UnaryOp", n.op, file=sys.stderr)

            case c_ast.FuncCall():
                if not isinstance(n.name, (c_ast.ID)):
                    print('call operator on some non-ID node', n.name, file=sys.stderr)
                    return

                self.push_expr(')')

                if n.args:
                    self.push_expr(n.args.exprs[0])
                    for i in reversed(n.args.exprs[1:]):
                        self.push_expr(',')
                        self.push_expr(i)
                
                self.push_expr('(')
                self.push_expr(n.name.name)

            case c_ast.TernaryOp():
                self.push_expr(')')
                self.push_expr(n.iffalse)
                self.push_expr(') else (')
                self.push_expr(n.cond)
                self.push_expr(' if (')
                self.push_expr(n.iftrue)

            case c_ast.Cast():
                self.push_expr(')')
                self.push_expr(n.expr)
                self.push_expr('(')
                self.push_expr(n.to_type)

            case c_ast.Union() | c_ast.Enum():
                self.push_expr(n.name)

            case _:
                if n is not None:
                    print('Unknown ast type:', type(n), file=sys.stderr)
                    print(str(n), file=sys.stderr)
                    self.push_newline(depth)
                    self.push_expr('pass')

def c2py(input_c_file, output_py_file, ignore_syms):
    # Create the parser and ask to parse the text. parse() will throw
    # a ParseError if there's an error in the code

    text = pycparser.preprocess_file(input_c_file)

    start_line=0
    parser = c_parser.CParser()
    input_ast = parser.parse(text, filename=input_c_file)

    f = open(output_py_file ,'w')

    # add transpiled code
    b=io.StringIO()
    a2py = Ast2Py(ignore_symbols=ignore_syms)
    a2py.ast2py(input_ast, b)
    py_cont = b.getvalue()

    # add required imports
    py_code = a2py.import_list()

    f.write(py_code)
    f.write(py_cont)

    # add entry point so that program can actually be run
    f.write('\n\n\n')
    f.write('if __name__ == "__main__":\n')
    f.write('\tmain()\n')

# end of file cpp2py.py


import sys


if __name__ == '__main__':
    if len(sys.argv) < 3:
        print('usage: c2py input.c output.py [ignore-symbols-file]', file=sys.stderr)
        exit(1)

    file_in = sys.argv[1]
    file_out = sys.argv[2]
    ignore_syms = set()
    if len(sys.argv) > 3:
        with open(sys.argv[3]) as file_syms:
            ignore_syms = set(l.strip() for l in file_syms.readlines())

    c2py(file_in, file_out, ignore_syms)

    exit_code = 1
    try: 
        with open(file_out, 'r') as f:
            ast.parse(f.read())
        exit_code = 0
    except BaseException as x:
        print('Could not generate valid python program:', file=sys.stderr)
        print(x, file=sys.stderr)
        exit_code = 1

    exit(exit_code)

